<!doctype html><html dir=ltr lang=en data-theme class=html><head><title>Eugene Khvedchenya
|
How to write a good code</title><meta charset=utf-8><meta name=generator content="Hugo 0.98.0"><meta name=viewport content="width=device-width,initial-scale=1,viewport-fit=cover"><meta name=author content="Eugene Khvedchenya"><meta name=description content="A personal blog about Computer Vision, AI, Kaggle, Open-Source and research. You will never read this in books."><link rel=stylesheet href=/scss/main.min.b2e0cb07595e3519ab1193bb421914e06c0e26b0cc561fef23b3c6131d4d2ffa.css integrity="sha256-suDLB1leNRmrEZO7QhkU4GwOJrDMVh/vI7PGEx1NL/o=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/css/markupHighlight.min.31b0a1f317f55c529a460897848c97436bb138b19c399b37de70d463a8bf6ed5.css integrity="sha256-MbCh8xf1XFKaRgiXhIyXQ2uxOLGcOZs33nDUY6i/btU=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/fontawesome/css/fontawesome.min.7d272de35b410fb165377550cdf9c4d3a80fbbcc961e111914e4d5c0eaf5729f.css integrity="sha256-fSct41tBD7FlN3VQzfnE06gPu8yWHhEZFOTVwOr1cp8=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/fontawesome/css/solid.min.55d8333481b07a08e07cf6f37319753a2b47e99f4c395394c5747b48b495aa9b.css integrity="sha256-VdgzNIGwegjgfPbzcxl1OitH6Z9MOVOUxXR7SLSVqps=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/fontawesome/css/regular.min.a7448d02590b43449364b6b5922ed9af5410abb4de4238412a830316dedb850b.css integrity="sha256-p0SNAlkLQ0STZLa1ki7Zr1QQq7TeQjhBKoMDFt7bhQs=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/fontawesome/css/brands.min.9ed75a5d670c953fe4df935937674b4646f92674367e9e66eb995bb04e821647.css integrity="sha256-ntdaXWcMlT/k35NZN2dLRkb5JnQ2fp5m65lbsE6CFkc=" crossorigin=anonymous type=text/css><link rel="shortcut icon" href=/favicon.ico type=image/x-icon><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=canonical href=https://computer-vision-talks.com/post/how-to-write-good-code/><script type=text/javascript src=/js/anatole-header.min.f9132794301a01ff16550ed66763482bd848f62243d278f5e550229a158bfd32.js integrity="sha256-+RMnlDAaAf8WVQ7WZ2NIK9hI9iJD0nj15VAimhWL/TI=" crossorigin=anonymous></script>
<script type=text/javascript src=/js/anatole-theme-switcher.min.560a26330d27ff44a44e83b53cd07a95d4230a65930d31c5c76a8d481e5b35bf.js integrity="sha256-VgomMw0n/0SkToO1PNB6ldQjCmWTDTHFx2qNSB5bNb8=" crossorigin=anonymous></script><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://computer-vision-talks.com/post/how-to-write-good-code/featured-image.jpg"><meta name=twitter:title content="How to write a good code"><meta name=twitter:description content="This article is a quintessence of my all experience I&rsquo;ve got for last years working as a computer vision consultant. I hope you will find this interesting and useful. My goal was to create set of rules I follow personally on daily basis.
1. Prefer functional approach Image processing is a place where functional paradigm shows it&rsquo;s bests. In most cases, image processing algorithm depends only on input image and has no side effects."><meta property="og:title" content="How to write a good code"><meta property="og:description" content="This article is a quintessence of my all experience I&rsquo;ve got for last years working as a computer vision consultant. I hope you will find this interesting and useful. My goal was to create set of rules I follow personally on daily basis.
1. Prefer functional approach Image processing is a place where functional paradigm shows it&rsquo;s bests. In most cases, image processing algorithm depends only on input image and has no side effects."><meta property="og:type" content="article"><meta property="og:url" content="https://computer-vision-talks.com/post/how-to-write-good-code/"><meta property="og:image" content="https://computer-vision-talks.com/post/how-to-write-good-code/featured-image.jpg"><meta property="article:section" content="post"><meta property="article:published_time" content="2015-09-09T00:00:00+00:00"><meta property="article:modified_time" content="2015-09-09T00:00:00+00:00"><meta property="og:site_name" content="Computer Vision Talks"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","articleSection":"post","name":"How to write a good code","headline":"How to write a good code","alternativeHeadline":"","description":"
      
        This article is a quintessence of my all experience I\u0026rsquo;ve got for last years working as a computer vision consultant. I hope you will find this interesting and useful. My goal was to create set of rules I follow personally on daily basis.\n1. Prefer functional approach Image processing is a place where functional paradigm shows it\u0026rsquo;s bests. In most cases, image processing algorithm depends only on input image and has no side effects.


      


    ","inLanguage":"en-us","isFamilyFriendly":"true","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/computer-vision-talks.com\/post\/how-to-write-good-code\/"},"author":{"@type":"Person","name":"Eugene Khvedchenya"},"creator":{"@type":"Person","name":"Eugene Khvedchenya"},"accountablePerson":{"@type":"Person","name":"Eugene Khvedchenya"},"copyrightHolder":{"@type":"Person","name":"Eugene Khvedchenya"},"copyrightYear":"2015","dateCreated":"2015-09-09T00:00:00.00Z","datePublished":"2015-09-09T00:00:00.00Z","dateModified":"2015-09-09T00:00:00.00Z","publisher":{"@type":"Organization","name":"Eugene Khvedchenya","url":"https://computer-vision-talks.com/","logo":{"@type":"ImageObject","url":"https:\/\/computer-vision-talks.com\/favicon-32x32.png","width":"32","height":"32"}},"image":[],"url":"https:\/\/computer-vision-talks.com\/post\/how-to-write-good-code\/","wordCount":"1824","genre":[],"keywords":["news","digest","cpp"]}</script></head><body class="body theme--light"><div class=wrapper><aside class=wrapper__sidebar><div class="sidebar
animated fadeInDown"><div class=sidebar__content><div class=sidebar__introduction><img class=sidebar__introduction-profileimage src=/images/4ECfkGJr_400x400.jpg alt="profile picture"><div class=sidebar__introduction-title><a href=/>Computer Vision Talks</a></div><div class=sidebar__introduction-description><p>A personal blog about Computer Vision, AI, Kaggle, Open-Source and research. You will never read this in books.</p></div></div><ul class=sidebar__list><li class=sidebar__list-item><a href=https://www.linkedin.com/in/cvtalks/ target=_blank rel=noopener aria-label=Linkedin title=Linkedin><i class="fab fa-linkedin fa-2x" aria-hidden=true></i></a></li><li class=sidebar__list-item><a href=https://twitter.com/cvtalks target=_blank rel=noopener aria-label=Twitter title=Twitter><i class="fab fa-twitter fa-2x" aria-hidden=true></i></a></li><li class=sidebar__list-item><a href=https://github.com/BloodAxe target=_blank rel=noopener aria-label=GitHub title=GitHub><i class="fab fa-github fa-2x" aria-hidden=true></i></a></li><li class=sidebar__list-item><a href=mailto:ekhvedchenya@computer-vision-talks.com target=_blank rel=noopener aria-label=E-Mail title=E-Mail><i class="fas fa-envelope fa-2x" aria-hidden=true></i></a></li></ul></div><footer class="footer footer__sidebar"><ul class=footer__list><li class=footer__item>&copy;
Eugene Khvedchenya
2022</li></ul></footer><script type=text/javascript src=/js/medium-zoom.min.9c062c557275acbaba71f0c7cd4024da3e3cc825d248bc4b2130811b0965330b.js integrity="sha256-nAYsVXJ1rLq6cfDHzUAk2j48yCXSSLxLITCBGwllMws=" crossorigin=anonymous></script>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-10687369-5","auto"),ga("send","pageview"))</script><script async src=https://www.google-analytics.com/analytics.js></script></div></aside><main class=wrapper__main><header class=header><div class="animated fadeInDown"><a role=button class=navbar-burger data-target=navMenu aria-label=menu aria-expanded=false><span aria-hidden=true class=navbar-burger__line></span>
<span aria-hidden=true class=navbar-burger__line></span>
<span aria-hidden=true class=navbar-burger__line></span></a><nav class=nav><ul class=nav__list id=navMenu><li class=nav__list-item><a href=/ title>Home</a></li><li class=nav__list-item><a href=/post/ title>Posts</a></li><li class=nav__list-item><a href=/open-source title>Open-Source</a></li><li class=nav__list-item><a href=/challenges title>Wins</a></li><li class=nav__list-item><a href=/publications title>Publications</a></li></ul><ul class="nav__list nav__list--end"><li class=nav__list-item><div class=themeswitch><a title="Switch Theme"><i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></li></ul></nav></div></header><div class="post
animated fadeInDown"><div class=post__content><h1>How to Write a Good Code</h1><ul class=post__meta><li class=post__meta-item><em class="fas fa-calendar-day post__meta-icon"></em>
<span class=post__meta-text>Wed, Sep 9, 2015</span></li><li class=post__meta-item><em class="fas fa-stopwatch post__meta-icon"></em>
<span class=post__meta-text>9-minute read</span></li></ul><p>This article is a quintessence of my all experience
I&rsquo;ve got for last years working as a computer vision consultant.
I hope you will find this interesting and useful.
My goal was to create set of rules I follow personally on daily basis.</p><h1 id=1-prefer-functional-approach>1. Prefer functional approach</h1><p><img src=fp.png alt></p><p>Image processing is a place where functional paradigm shows it&rsquo;s bests.
In most cases, image processing algorithm depends only on input image and has no side effects.
This fits perfectly to a &lsquo;pure function&rsquo; term. When possible try to follow this checklist when you define a function in your code:</p><ul><li>Mark all input data with <code>const</code> modifier to specify immutable arguments.</li><li>Prefer return by reference for large objects (especially for images) instead returning by value.</li><li>In case of class methods, mark methods that does not change class internal state with <code>const</code> modifier.</li></ul><p>These simple advice helps to understand what and when can you function change. You may remember tricky details of your code today, but who guarantees you&rsquo;ll easily remember that in a month?</p><p>For instance, I want to write implementation of template matching. One may write it as follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>TemplateMatchingAlgorithm</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=n>TemplateMatchingAlgorithm</span><span class=p>(</span><span class=n>cv</span><span class=o>::</span><span class=n>Mat</span> <span class=n>templateImage</span><span class=p>,</span> <span class=kt>int</span> <span class=n>method</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>cv</span><span class=o>::</span><span class=n>Point</span> <span class=n>matchTemplate</span><span class=p>(</span><span class=n>cv</span><span class=o>::</span><span class=n>Mat</span> <span class=n>queryImage</span><span class=p>)</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=n>cv</span><span class=o>::</span><span class=n>Mat</span> <span class=n>_templateImage</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span>   <span class=n>_method</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>Compare it with function declaration that does the same job, but looks much cleaner:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>MatchTemplate</span><span class=p>(</span><span class=n>cv</span><span class=o>::</span><span class=n>Mat</span> <span class=n>templateImage</span><span class=p>,</span> <span class=n>cv</span><span class=o>::</span><span class=n>Mat</span> <span class=n>queryImage</span><span class=p>,</span> <span class=n>cv</span><span class=o>::</span><span class=n>Point</span><span class=o>&amp;</span> <span class=n>minPoint</span><span class=p>,</span> <span class=kt>int</span> <span class=n>method</span><span class=p>);</span>
</span></span></code></pre></div><p>So you may ask, should I create class with const method or declare an ordinary function instead?
The short answer - functions are better. I personally use simple decision algorithm:</p><h2 id=2-dont-use-virtual-methods>2. Don&rsquo;t use virtual methods</h2><p><img src=virtualmethods.png alt></p><p>You may argue - with classes we can define various implementations for <code>TemplateMatching</code> using SIDM, CUDA or use template matching in Fourier domain.
Yes, we can. But the price we pay for each call of virtual method is too big for such small routine as template matching.
Usually we use TemplateMatching on small patches like 11x11 pixels to track translation between two frames of video. Hence to achieve robust tracking, number of patches can be quite high - 500 and even 1000 per one frame. Further, coarse-to-fine matching and sub-pixel optimization can lead to ten or more calls for the same feature. In this case, virtual call is a big no-no that will kill your application&rsquo;s performance.</p><h2 id=3-write-regression-tests>3. Write regression tests</h2><p><img src=regression.jpg alt></p><p>Regression testing is a great tool to track all changes in your algorithm and measure it&rsquo;s
precision and performance. Here&rsquo;s an idea:</p><ul><li>Create a ground-truth input dataset</li><li>Process it with your algorithm.</li><li>Save output data and track it in your version control system.</li><li>Each time you make changes in implementation - run regression on same input data and compare results.</li></ul><p>Regression testing can easily spot numeric stability problems on different compilers / platforms, introduced bugs, platform-dependent optimizations. It&rsquo;s a good idea to include it as a part of regular unit testing:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>BOOST_AUTO_TEST_CASE(MyAlgorithm, createRegressionDatabaset)
</span></span></span><span class=line><span class=cl><span class=cm>{
</span></span></span><span class=line><span class=cl><span class=cm>    ...
</span></span></span><span class=line><span class=cl><span class=cm>}
</span></span></span><span class=line><span class=cl><span class=cm>/**/</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>BOOST_AUTO_TEST_CASE</span><span class=p>(</span><span class=n>MyAlgorithm</span><span class=p>,</span> <span class=n>checkRegression</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>I intentionally commented out first test case - in ideal world it should be executed only once.
But sometimes it&rsquo;s necessary to update ground-truth (you fixed a bug in original implementation).
So you uncomment it, run tests, comment it back and check-in new ground-truth.</p><p>You may use any format you like for dumping ground truth data (usually it&rsquo;s some matrices, vectors or images).
Personally, I prefer YAML and JSON.
Just ensure when dumping floating-point numbers to specify maximum output precision.
Otherwise you will have funny weekend debugging absolutely correct algorithm with failing assertion check <code>0.1543642342365 != 0.154364</code>.</p><h2 id=4-add-logging-to-your-code>4. Add logging to your code</h2><p><img src=logging.jpg alt></p><p>In the simplest case, it could be trivial console logging.
In debug mode you will have all messages in stdout, but in release it will be totally excluded from compilation step.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#if _DEBUG
</span></span></span><span class=line><span class=cl><span class=cp>#define LOG_MESSAGE(x) std::cout &lt;&lt; __FILE__ &lt;&lt; &#34; (&#34; &lt;&lt; __LINE__ &lt;&lt; &#34;): &#34; &lt;&lt; x &lt;&lt; std::endl;
</span></span></span><span class=line><span class=cl><span class=cp>#else
</span></span></span><span class=line><span class=cl><span class=cp>#define LOG_MESSAGE(x)
</span></span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span></code></pre></div><p>For complex systems I suggest to use mature logging frameworks like Boost::Log or similar.
They has separation of logging streams (info, trace, warning, errors) and deal with multi-threaded logging.
Logging to file is also useful feature when you want to store program output for further analysis.</p><p>In one of my previous projects, there was a standalone program for logs analysis and data visualization. We logged
all - matrices, vectors regular messages with timestamps. After program finishes we were able to trace program flow
frame by frame and analyze how our algorithms behaved. I cannot count how much hours this tool saved to us on data analysis.</p><p>Logging also helps to spot nasty bugs when you have inconsistent behavior on different platforms. For instance, not so recently I faced a problem when optical flow tracker gave different results on iOS and OSX platforms. After logging all input/output and intermediate data including vectors, matrices I found the root of the evil. It was <code>std::log</code> function.</p><h2 id=5-profile-your-code>5. Profile your code</h2><p><img src=profilerdump.png alt></p><p>Algorithm performance usually a top-level priority since this kind of applications deal with real-time video processing and processing of huge amount of data.
Therefore it&rsquo;s crucial to know how fast your algorithms runs or do they become slower or faster with refactoring you perform.
There are plenty of ways to collect this data.</p><h3 id=xcode-instruments>XCode Instruments</h3><p>If you&rsquo;re targeting on OSX and iOS platform, Apple Xcode and Instruments can be your first choice due to natural integration of profiling tools to IDE.
Instruments can be handy to spot problematic places in your code. But Instruments uses sampling technique, which is not precise.</p><h3 id=vtunevisualstudio>VTune/VisualStudio</h3><p>For Windows users Visual Studio offers integrated profiler as well.
Unlike Instruments, it can do instrumentation of your binary.
It means each function in your program modified with special prolog and epilog code that measure execution time of all your program.
Instrumenting provides you a lot of information per each routine: calls count, execution time, inclusive / exclusive CPU time, call tread and CPU cores load.
This is much more you have with Apple Instruments.</p><h3 id=cvgettickcount>cv::getTickCount</h3><p>Sometimes you don&rsquo;t want to profile entire application. Instead you want to &lsquo;cherry-pick&rsquo; only a single function and profile it. For this purpose you can use monotonic clock and measure execution time:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#define MEASURE_TIME(x)                        \
</span></span></span><span class=line><span class=cl><span class=cp>        { auto startTime = cv::getTickCount(); \ 
</span></span></span><span class=line><span class=cl><span class=cp></span>          <span class=n>x</span><span class=p>;</span>                                   \
</span></span><span class=line><span class=cl>          <span class=k>auto</span> <span class=n>endTime</span> <span class=o>=</span> <span class=n>cv</span><span class=o>::</span><span class=n>getTickCount</span><span class=p>();</span>   \
</span></span><span class=line><span class=cl>          <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=err>#</span><span class=n>x</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; &#34;</span> <span class=o>&lt;&lt;</span> <span class=p>(</span><span class=n>endTime</span> <span class=o>-</span> <span class=n>startTime</span><span class=p>)</span> <span class=o>*</span> <span class=n>cv</span><span class=o>::</span><span class=n>getTickFrequency</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Measure MatchTemplate
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>MEASURE_TIME</span><span class=p>(</span><span class=n>MatchTemplate</span><span class=p>(</span><span class=n>a</span><span class=p>,</span><span class=n>b</span><span class=p>,</span><span class=n>result</span><span class=p>));</span>
</span></span></code></pre></div><h2 id=6-optimize-code>6. Optimize code</h2><h3 id=61-loop-vectorization>6.1 Loop vectorization</h3><p>Compilers can do loops vectorization when data flow and iterations count are clear enough.
This heuristic analysis depends on implementation, so CLang has different vectorization analysis engine than MSVC. But you can give your compiler a hint:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>SSD</span><span class=p>(</span><span class=n>cv</span><span class=o>::</span><span class=n>Mat</span> <span class=n>i1</span><span class=p>,</span> <span class=n>cv</span><span class=o>::</span><span class=n>Mat</span> <span class=n>i2</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=kt>uint8_t</span> <span class=o>*</span> <span class=n>a</span> <span class=o>=</span> <span class=n>templateImage</span><span class=p>.</span><span class=n>data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=kt>uint8_t</span> <span class=o>*</span> <span class=n>b</span> <span class=o>=</span> <span class=n>templateImage</span><span class=p>.</span><span class=n>data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>ssd</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>(;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=p>(</span><span class=n>length</span><span class=o>/</span><span class=mi>4</span><span class=p>)</span><span class=o>*</span><span class=mi>4</span><span class=p>;</span> <span class=n>i</span><span class=o>+=</span><span class=mi>4</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>ssd</span> <span class=o>+=</span> <span class=n>SQR</span><span class=p>(</span><span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=o>+</span><span class=mi>0</span><span class=p>]</span> <span class=o>-</span> <span class=n>b</span><span class=p>[</span><span class=n>i</span><span class=o>+</span><span class=mi>0</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=n>ssd</span> <span class=o>+=</span> <span class=n>SQR</span><span class=p>(</span><span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>]</span> <span class=o>-</span> <span class=n>b</span><span class=p>[</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=n>ssd</span> <span class=o>+=</span> <span class=n>SQR</span><span class=p>(</span><span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=o>+</span><span class=mi>2</span><span class=p>]</span> <span class=o>-</span> <span class=n>b</span><span class=p>[</span><span class=n>i</span><span class=o>+</span><span class=mi>2</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=n>ssd</span> <span class=o>+=</span> <span class=n>SQR</span><span class=p>(</span><span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=o>+</span><span class=mi>3</span><span class=p>]</span> <span class=o>-</span> <span class=n>b</span><span class=p>[</span><span class=n>i</span><span class=o>+</span><span class=mi>3</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>(;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>length</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>,</span> <span class=n>a</span><span class=o>++</span><span class=p>,</span> <span class=n>b</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>ssd</span> <span class=o>+=</span> <span class=n>SQR</span><span class=p>(</span><span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>-</span> <span class=n>b</span><span class=p>[</span><span class=n>i</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>ssd</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>This partial loop unrolling gives enough information to compiler.
As a result it can replace partially unrolled summation with SIMD instruction.</p><h3 id=62-bring-constants-at-compile-time>6.2 Bring constants at compile time</h3><p>If you have a priory knowledge on size of data you pass to particular function, it may make sense to write function that
employs this information:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>TOut</span><span class=p>,</span> <span class=k>typename</span> <span class=n>TIn</span><span class=p>,</span> <span class=kt>int</span> <span class=n>RowsAtCompileTime</span><span class=p>,</span> <span class=kt>int</span> <span class=n>ColsAtCompileTime</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kr>inline</span> <span class=n>TOut</span> <span class=n>SSD</span><span class=p>(</span><span class=k>const</span> <span class=n>cv</span><span class=o>::</span><span class=n>Matx_</span><span class=o>&lt;</span><span class=n>TIn</span><span class=p>,</span> <span class=n>RowsAtCompileTime</span><span class=p>,</span> <span class=n>ColsAtCompileTime</span><span class=o>&gt;&amp;</span> <span class=n>a</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>                <span class=k>const</span> <span class=n>cv</span><span class=o>::</span><span class=n>Matx_</span><span class=o>&lt;</span><span class=n>TIn</span><span class=p>,</span> <span class=n>RowsAtCompileTime</span><span class=p>,</span> <span class=n>ColsAtCompileTime</span><span class=o>&gt;&amp;</span> <span class=n>b</span><span class=p>)</span> <span class=n>nothrow</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=n>TIn</span> <span class=o>*</span> <span class=n>a</span> <span class=o>=</span> <span class=n>templateImage</span><span class=p>.</span><span class=n>data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=n>TIn</span> <span class=o>*</span> <span class=n>b</span> <span class=o>=</span> <span class=n>templateImage</span><span class=p>.</span><span class=n>data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=n>TOut</span> <span class=n>ssd</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>RowsAtCompileTime</span> <span class=o>*</span> <span class=n>ColsAtCompileTime</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>,</span> <span class=n>a</span><span class=o>++</span><span class=p>,</span> <span class=n>b</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>ssd</span> <span class=o>+=</span> <span class=p>(</span><span class=n>TOut</span><span class=p>)</span><span class=n>SQR</span><span class=p>(</span><span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>-</span> <span class=n>b</span><span class=p>[</span><span class=n>i</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>ssd</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Since compiler knows size of the array to process, it can easily generate vectorized code for this routine.
The drawback of this approach is slightly increased code size if you instantiate this template function with many sizes.
But you get better performance which usually worth it.</p><h3 id=63-architecture-dependent-implementations>6.3 Architecture-dependent implementations</h3><p>Architecture-specific features like SIMD instructions can make your code runs much, much faster than generic C++
implementation.
It is a must-have feature on mobile platforms since it makes your code faster and at the same time it
conservate battery power of host device.
There are more and more devices with CUDA and OpenCL support.
And the question is - how do I manage all those possible architecture / platforms combinations of optimized functions in my code?</p><p>Here it&rsquo;s how I solved this task for myself:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>namespace</span> <span class=n>mypublicnamespace</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>MatchTemplate</span><span class=p>(</span><span class=n>cv</span><span class=o>::</span><span class=n>Mat</span> <span class=n>templateImage</span><span class=p>,</span> <span class=n>cv</span><span class=o>::</span><span class=n>Mat</span> <span class=n>queryImage</span><span class=p>,</span> <span class=n>cv</span><span class=o>::</span><span class=n>Point</span><span class=o>&amp;</span> <span class=n>minPoint</span><span class=p>,</span> <span class=kt>int</span> <span class=n>method</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=cp>#if TARGET_PLATFORM_HAS_NEON_SIMD
</span></span></span><span class=line><span class=cl><span class=cp></span>        <span class=n>details</span><span class=o>::</span><span class=n>neon</span><span class=o>::</span><span class=n>MatchTemplate</span><span class=p>(</span><span class=n>templateImage</span><span class=p>,</span> <span class=n>queryImage</span><span class=p>,</span> <span class=n>minPoint</span><span class=p>,</span> <span class=n>method</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=cp>#elif TARGET_PLATFORM_HAS_SSE_SIMD
</span></span></span><span class=line><span class=cl><span class=cp></span>        <span class=n>details</span><span class=o>::</span><span class=n>sse</span><span class=o>::</span><span class=n>MatchTemplate</span><span class=p>(</span><span class=n>templateImage</span><span class=p>,</span> <span class=n>queryImage</span><span class=p>,</span> <span class=n>minPoint</span><span class=p>,</span> <span class=n>method</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=cp>#elif TARGET_PLATFORM_HAS_OPENCL
</span></span></span><span class=line><span class=cl><span class=cp></span>        <span class=n>details</span><span class=o>::</span><span class=n>opencl</span><span class=o>::</span><span class=n>MatchTemplate</span><span class=p>(</span><span class=n>templateImage</span><span class=p>,</span> <span class=n>queryImage</span><span class=p>,</span> <span class=n>minPoint</span><span class=p>,</span> <span class=n>method</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=cp>#else        
</span></span></span><span class=line><span class=cl><span class=cp></span>        <span class=n>details</span><span class=o>::</span><span class=n>generic</span><span class=o>::</span><span class=n>MatchTemplate</span><span class=p>(</span><span class=n>templateImage</span><span class=p>,</span> <span class=n>queryImage</span><span class=p>,</span> <span class=n>minPoint</span><span class=p>,</span> <span class=n>method</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=cp>#endif    
</span></span></span><span class=line><span class=cl><span class=cp></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>This code snippet demonstrate compile-time dispatching for particular implementation of a function declared in <code>mypublicnamespace</code>. Of course, you should take care of preprocessor defines that declare platform / architecture capabilities. I</p><h3 id=64-branch-prediction>6.4 Branch prediction</h3><p>Suppose you have a-priory knowledge that condition expression will be almost always true.
Why don&rsquo;t give this intrinsic knowledge to compiler? By supplying <em>expected</em> condition result compiler can
generate more efficient code. As a result, CPU will start decoding instructions earlier.</p><p>Unfortunately, this feature supported only on GCC and CLANG.
But according to measurements, it can provide significant speed-up up to ~15%. You can find more information here: <a href=http://blog.man7.org/2012/10/how-much-do-builtinexpect-likely-and.html>How much do __builtin_expect(), likely(), and unlikely() improve performance?</a>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#define LIKELY(x)      __builtin_expect(!!(x), 1)
</span></span></span><span class=line><span class=cl><span class=cp>#define UNLIKELY(x)    __builtin_expect(!!(x), 0)
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>LIKELY</span><span class=p>(</span><span class=n>x</span> <span class=o>&gt;=</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=n>x</span> <span class=o>&lt;=</span> <span class=n>image_width</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// Compute something
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>UNLIKELY</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>fabs</span><span class=p>(</span><span class=n>value</span><span class=p>)</span> <span class=o>&lt;=</span> <span class=n>std</span><span class=o>::</span><span class=n>numeric_limits</span><span class=o>&lt;</span><span class=kt>float</span><span class=o>&gt;::</span><span class=n>epsilon</span><span class=p>()))</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>throw</span> <span class=n>std</span><span class=o>::</span><span class=n>runtime_error</span><span class=p>(</span><span class=s>&#34;Value is zero&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=65-openmp>6.5 OpenMP</h3><p>Starting from OpenMP 4.0, you can instruct compiler to generate vectorized code by adding new pragma instructions to your loops:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>MatchTemplate</span><span class=p>(</span><span class=n>cv</span><span class=o>::</span><span class=n>Mat</span> <span class=n>templateImage</span><span class=p>,</span> <span class=n>cv</span><span class=o>::</span><span class=n>Mat</span> <span class=n>queryImage</span><span class=p>,</span> <span class=n>cv</span><span class=o>::</span><span class=n>Point</span><span class=o>&amp;</span> <span class=n>minPoint</span><span class=p>,</span> <span class=kt>int</span> <span class=n>method</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>uint8_t</span> <span class=o>*</span> <span class=n>a</span> <span class=o>=</span> <span class=n>templateImage</span><span class=p>.</span><span class=n>data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>uint8_t</span> <span class=o>*</span> <span class=n>b</span> <span class=o>=</span> <span class=n>templateImage</span><span class=p>.</span><span class=n>data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>ssd</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#pragma omp simd reduction(+:x)
</span></span></span><span class=line><span class=cl><span class=cp></span>  <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>length</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>ssd</span> <span class=o>+=</span> <span class=n>SQR</span><span class=p>(</span><span class=n>a</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>-</span> <span class=n>b</span><span class=p>[</span><span class=mi>0</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>With only single <code>#pragma</code> instruction you made your code runs faster.
I encourage you to visit <a href=https://software.intel.com/en-us/articles/enabling-simd-in-program-using-openmp40>Enabling SIMD in program using OpenMP4.0</a> webpage for more information of supported OpenMP SIMD instructions.</p><h3 id=7-use-imageview>7. Use ImageView</h3><p>For Windows users there is a great Visual Studio plugin called <a href=https://visualstudiogallery.msdn.microsoft.com/e682d542-7ef3-402c-b857-bbfba714f78d>ImageWatch</a> that makes our life so simple.
This plugin can visualize OpenCV matrices right in IDE.
It is hard to overestimate the usefulness of this plugin.
You can see how images are changing while debugging.</p><p><img src=image_watch.png alt="Image watch"></p><h1 id=conclusion>Conclusion</h1><p>Next time when you start development of new algorithm, keep in mind these simple steps.
They will help you create fast, maintainable and clear code. Here they are:</p><ol><li>Prefer functional approach</li><li>Try avoid virtual calls</li><li>Write vectorization-friendly code</li><li>Use all available debugging / profiling tools</li><li>Measure your code performance</li><li>Write tests and check regression</li></ol><p>Hope you found this post useful. Discussion is more than welcome. Please share your thoughts in comments.</p></div><div class=post__footer><span><a class=tag href=/tags/news/>news</a><a class=tag href=/tags/digest/>digest</a><a class=tag href=/tags/cpp/>cpp</a></span></div><div id=comment><h2>comments</h2><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//cvtalks.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></div></main></div><footer class="footer footer__base"><ul class=footer__list><li class=footer__item>&copy;
Eugene Khvedchenya
2022</li></ul></footer><script type=text/javascript src=/js/medium-zoom.min.9c062c557275acbaba71f0c7cd4024da3e3cc825d248bc4b2130811b0965330b.js integrity="sha256-nAYsVXJ1rLq6cfDHzUAk2j48yCXSSLxLITCBGwllMws=" crossorigin=anonymous></script>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-10687369-5","auto"),ga("send","pageview"))</script><script async src=https://www.google-analytics.com/analytics.js></script></body></html>