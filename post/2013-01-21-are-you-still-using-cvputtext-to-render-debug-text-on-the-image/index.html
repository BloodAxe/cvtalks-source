<!doctype html><html dir=ltr lang=en data-theme class=html><head><title>Eugene Khvedchenya
|
Are you still using cv::putText to render debug text on the image?</title><meta charset=utf-8><meta name=generator content="Hugo 0.98.0"><meta name=viewport content="width=device-width,initial-scale=1,viewport-fit=cover"><meta name=author content="Eugene Khvedchenya"><meta name=description content="A personal blog about Computer Vision, AI, Kaggle, Open-Source and research. You will never read this in books."><link rel=stylesheet href=/scss/main.min.b2e0cb07595e3519ab1193bb421914e06c0e26b0cc561fef23b3c6131d4d2ffa.css integrity="sha256-suDLB1leNRmrEZO7QhkU4GwOJrDMVh/vI7PGEx1NL/o=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/css/markupHighlight.min.31b0a1f317f55c529a460897848c97436bb138b19c399b37de70d463a8bf6ed5.css integrity="sha256-MbCh8xf1XFKaRgiXhIyXQ2uxOLGcOZs33nDUY6i/btU=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/fontawesome/css/fontawesome.min.7d272de35b410fb165377550cdf9c4d3a80fbbcc961e111914e4d5c0eaf5729f.css integrity="sha256-fSct41tBD7FlN3VQzfnE06gPu8yWHhEZFOTVwOr1cp8=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/fontawesome/css/solid.min.55d8333481b07a08e07cf6f37319753a2b47e99f4c395394c5747b48b495aa9b.css integrity="sha256-VdgzNIGwegjgfPbzcxl1OitH6Z9MOVOUxXR7SLSVqps=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/fontawesome/css/regular.min.a7448d02590b43449364b6b5922ed9af5410abb4de4238412a830316dedb850b.css integrity="sha256-p0SNAlkLQ0STZLa1ki7Zr1QQq7TeQjhBKoMDFt7bhQs=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/fontawesome/css/brands.min.9ed75a5d670c953fe4df935937674b4646f92674367e9e66eb995bb04e821647.css integrity="sha256-ntdaXWcMlT/k35NZN2dLRkb5JnQ2fp5m65lbsE6CFkc=" crossorigin=anonymous type=text/css><link rel="shortcut icon" href=/favicon.ico type=image/x-icon><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=canonical href=https://computer-vision-talks.com/post/2013-01-21-are-you-still-using-cvputtext-to-render-debug-text-on-the-image/><script type=text/javascript src=/js/anatole-header.min.f9132794301a01ff16550ed66763482bd848f62243d278f5e550229a158bfd32.js integrity="sha256-+RMnlDAaAf8WVQ7WZ2NIK9hI9iJD0nj15VAimhWL/TI=" crossorigin=anonymous></script>
<script type=text/javascript src=/js/anatole-theme-switcher.min.560a26330d27ff44a44e83b53cd07a95d4230a65930d31c5c76a8d481e5b35bf.js integrity="sha256-VgomMw0n/0SkToO1PNB6ldQjCmWTDTHFx2qNSB5bNb8=" crossorigin=anonymous></script><meta name=twitter:card content="summary"><meta name=twitter:title content="Are you still using cv::putText to render debug text on the image?"><meta name=twitter:description content="During my research and development work i often have to display a lot of text infromation on top of the OpenCV images. You know what i mean. Suppose you&rsquo;re writing video stabilization algorithm. On each frame you want to display number of features visible on current frame, number of features matched with previois frame, camera motion parameters, recent twitters, name of your pet, etc.. In the OpenCV you can use cv::putText function to print formatted std::string at the desired position on the image."><meta property="og:title" content="Are you still using cv::putText to render debug text on the image?"><meta property="og:description" content="During my research and development work i often have to display a lot of text infromation on top of the OpenCV images. You know what i mean. Suppose you&rsquo;re writing video stabilization algorithm. On each frame you want to display number of features visible on current frame, number of features matched with previois frame, camera motion parameters, recent twitters, name of your pet, etc.. In the OpenCV you can use cv::putText function to print formatted std::string at the desired position on the image."><meta property="og:type" content="article"><meta property="og:url" content="https://computer-vision-talks.com/post/2013-01-21-are-you-still-using-cvputtext-to-render-debug-text-on-the-image/"><meta property="article:section" content="post"><meta property="article:published_time" content="2013-01-21T00:00:00+00:00"><meta property="article:modified_time" content="2013-01-21T00:00:00+00:00"><meta property="og:site_name" content="Computer Vision Talks"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","articleSection":"post","name":"Are you still using cv::putText to render debug text on the image?","headline":"Are you still using cv::putText to render debug text on the image?","alternativeHeadline":"","description":"
      
        During my research and development work i often have to display a lot of text infromation on top of the OpenCV images. You know what i mean. Suppose you\u0026rsquo;re writing video stabilization algorithm. On each frame you want to display number of features visible on current frame, number of features matched with previois frame, camera motion parameters, recent twitters, name of your pet, etc.. In the OpenCV you can use cv::putText function to print formatted std::string at the desired position on the image.


      


    ","inLanguage":"en-us","isFamilyFriendly":"true","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/computer-vision-talks.com\/post\/2013-01-21-are-you-still-using-cvputtext-to-render-debug-text-on-the-image\/"},"author":{"@type":"Person","name":"Eugene Khvedchenya"},"creator":{"@type":"Person","name":"Eugene Khvedchenya"},"accountablePerson":{"@type":"Person","name":"Eugene Khvedchenya"},"copyrightHolder":{"@type":"Person","name":"Eugene Khvedchenya"},"copyrightYear":"2013","dateCreated":"2013-01-21T00:00:00.00Z","datePublished":"2013-01-21T00:00:00.00Z","dateModified":"2013-01-21T00:00:00.00Z","publisher":{"@type":"Organization","name":"Eugene Khvedchenya","url":"https://computer-vision-talks.com/","logo":{"@type":"ImageObject","url":"https:\/\/computer-vision-talks.com\/favicon-32x32.png","width":"32","height":"32"}},"image":[],"url":"https:\/\/computer-vision-talks.com\/post\/2013-01-21-are-you-still-using-cvputtext-to-render-debug-text-on-the-image\/","wordCount":"802","genre":[],"keywords":["opencv"]}</script></head><body class="body theme--light"><div class=wrapper><aside class=wrapper__sidebar><div class="sidebar
animated fadeInDown"><div class=sidebar__content><div class=sidebar__introduction><img class=sidebar__introduction-profileimage src=/images/4ECfkGJr_400x400.jpg alt="profile picture"><div class=sidebar__introduction-title><a href=/>Computer Vision Talks</a></div><div class=sidebar__introduction-description><p>A personal blog about Computer Vision, AI, Kaggle, Open-Source and research. You will never read this in books.</p></div></div><ul class=sidebar__list><li class=sidebar__list-item><a href=https://www.linkedin.com/in/cvtalks/ target=_blank rel=noopener aria-label=Linkedin title=Linkedin><i class="fab fa-linkedin fa-2x" aria-hidden=true></i></a></li><li class=sidebar__list-item><a href=https://twitter.com/cvtalks target=_blank rel=noopener aria-label=Twitter title=Twitter><i class="fab fa-twitter fa-2x" aria-hidden=true></i></a></li><li class=sidebar__list-item><a href=https://github.com/BloodAxe target=_blank rel=noopener aria-label=GitHub title=GitHub><i class="fab fa-github fa-2x" aria-hidden=true></i></a></li><li class=sidebar__list-item><a href=mailto:ekhvedchenya@computer-vision-talks.com target=_blank rel=noopener aria-label=E-Mail title=E-Mail><i class="fas fa-envelope fa-2x" aria-hidden=true></i></a></li></ul></div><footer class="footer footer__sidebar"><ul class=footer__list><li class=footer__item>&copy;
Eugene Khvedchenya
2022</li></ul></footer><script type=text/javascript src=/js/medium-zoom.min.9c062c557275acbaba71f0c7cd4024da3e3cc825d248bc4b2130811b0965330b.js integrity="sha256-nAYsVXJ1rLq6cfDHzUAk2j48yCXSSLxLITCBGwllMws=" crossorigin=anonymous></script>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-10687369-5","auto"),ga("send","pageview"))</script><script async src=https://www.google-analytics.com/analytics.js></script></div></aside><main class=wrapper__main><header class=header><div class="animated fadeInDown"><a role=button class=navbar-burger data-target=navMenu aria-label=menu aria-expanded=false><span aria-hidden=true class=navbar-burger__line></span>
<span aria-hidden=true class=navbar-burger__line></span>
<span aria-hidden=true class=navbar-burger__line></span></a><nav class=nav><ul class=nav__list id=navMenu><li class=nav__list-item><a href=/ title>Home</a></li><li class=nav__list-item><a href=/post/ title>Posts</a></li><li class=nav__list-item><a href=/open-source title>Open-Source</a></li><li class=nav__list-item><a href=/challenges title>Wins</a></li><li class=nav__list-item><a href=/publications title>Publications</a></li></ul><ul class="nav__list nav__list--end"><li class=nav__list-item><div class=themeswitch><a title="Switch Theme"><i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></li></ul></nav></div></header><div class="post
animated fadeInDown"><div class=post__content><h1>Are You Still Using Cv::putText to Render Debug Text on the Image?</h1><ul class=post__meta><li class=post__meta-item><em class="fas fa-calendar-day post__meta-icon"></em>
<span class=post__meta-text>Mon, Jan 21, 2013</span></li><li class=post__meta-item><em class="fas fa-stopwatch post__meta-icon"></em>
<span class=post__meta-text>4-minute read</span></li></ul><p>During my research and development work i often have to display a lot of text infromation on top of the OpenCV images. You know what i mean. Suppose you&rsquo;re writing video stabilization algorithm. On each frame you want to display number of features visible on current frame, number of features matched with previois frame, camera motion parameters, recent twitters, name of your pet, etc.. In the OpenCV you can use <strong>cv::putText</strong> function to print formatted std::string at the desired position on the image. It&rsquo;s easy when you have a fixed string that won&rsquo;t change. But what should you do if you need to dynamically construct this string depending on the processing results?</p><p></p><p><strong>For unpatinet</strong>: Here is a pull request: <a href=https://github.com/Itseez/opencv/pull/313>https://github.com/Itseez/opencv/pull/313</a> for this feature. In this case you have to write next:</p><pre><code>{
	std::ostringstream str;
	str &lt; &lt; &quot;Number of features visible:&quot; &lt;&lt; numFeatures;
	cv::putText(image, cv::Point(10,10), str.str(), CV_FONT_HERSHEY_PLAIN, CV_RGB(0,0,250));
}

{
	std::ostringstream str;
	str &lt;&lt; &quot;Tracked features:&quot; &lt;&lt; trackedFeaturesCount;
	cv::putText(image, cv::Point(10,30), str.str(), CV_FONT_HERSHEY_PLAIN, CV_RGB(0,0,250));
}

{
	std::ostringstream str;
	str &lt;&lt; &quot;Camera motion:&quot; &lt;&lt; camMotionMat;
	cv::putText(image, cv::Point(10,50), str.str(), CV_FONT_HERSHEY_PLAIN, CV_RGB(0,0,250));
}
</code></pre><p>I can&rsquo;t count how many times i wrote this mess. Unfortunately, cv::putText cannot deal with <strong>\n</strong> and wrap lines. Personally, i wasn&rsquo;t satisfied with text output interface that OpenCV provide. So i decided to contribute a small improvement that helps to solve mentioned problems. The proposed patch allows to print text using <strong>operator&lt; &lt;</strong> idiom. **<strong>Printing text on the image can be done exactly as printing to std::cout</strong>:</p><pre><code>cv::putText(image2, cv::Point(100,100), CV_FONT_HERSHEY_COMPLEX, 1, Scalar(i, i, 255))
	&lt; &lt; &quot;cv::putText() Demo!&quot; &lt;&lt; std::endl 
	&lt;&lt; &quot;cv::putText(...) &lt;&lt; \&quot;Hello\\nWorld\&quot;;&quot; &lt;&lt; std::endl 
	&lt;&lt; &quot;You can use std::endl&quot; &lt;&lt; std::endl 
	&lt;&lt; &quot;or even\\n symbol\nto format text&quot; &lt;&lt; std::endl
	&lt;&lt; &quot;And we support formatters:\n&quot;
	&lt;&lt; &quot;std::setprecision(5)&quot; &lt;&lt; std::setprecision(5) &lt;&lt; CV_PI &lt;&lt; std::endl
	&lt;&lt; &quot;std::scientific &quot; &lt;&lt; std::scientific &lt;&lt; CV_PI &lt;&lt; std::endl
	&lt;&lt; &quot;So you can use cv::putText like regular std::cout!&quot;;
</code></pre><p>The result will be: <img src=putTextOstream.png alt=putTextOstream> The new cv::putText allows you to:</p><ul><li>Use ostream-like operator&lt; &lt; to print text on cv::Mat like you print &ldquo;Hello world&rdquo; to std::cout</li><li>Ostream-like cv::putText supports newline (<strong>\n</strong>) character and <strong>std::endl</strong> manipulator and wraps text to the next line</li><li>Support printing of all OpenCV types like <strong>cv::Mat</strong>, <strong>cv::Point</strong>, <strong>cv::Scalar</strong> and so on
I made a pull-request to OpenCV repository on Github and i hope it will be added into the distribution soon. You can access it by following this link: <a href=https://github.com/Itseez/opencv/pull/313>https://github.com/Itseez/opencv/pull/313</a>. You can find a demonstration of the new putText in the samples (<a href=https://github.com/BloodAxe/opencv/blob/a546d1ffcbd69902cc99b04ad94bc24065e2b184/samples/cpp/drawing.cpp>drawing.cpp</a>).</li></ul><h2 id=implementation-details>Implementation details</h2><p>The magic begins in the new cv::putText function:</p><pre><code>//! Creates and return image_ostream object to render text on the image like the std::cout does.
//! An image_ostream class supports operator&lt; &lt; for both primitive and opencv types.
static inline image_ostream putText( Mat&amp; img, Point org,
    int fontFace, double fontScale, Scalar color,
    int thickness=1, int lineType=8,
    bool bottomLeftOrigin=false )
{
    return image_ostream(img, org, fontFace, fontScale, color, thickness, lineType, bottomLeftOrigin);
}
</code></pre><p>As you can see, the new putText function does not have string argument to print. Instead of it it returns a <strong>image_ostream</strong> object. This is a special type that behaves like the regular std::ostream class. This means you can use the same operator&lt; &lt; and iostream manipulators to do text printing. The main difference between std::ostream and image_ostream that the last one redirects the text output to the cv::Mat object.</p><pre><code>//! Define the custom class that behaves like the std::basic_ostream but renders the text on the cv::Mat
class CV_EXPORTS image_ostream
{
public:
    image_ostream(Mat&amp; img, Point org, int fontFace, double fontScale, Scalar color, int thickness=1, int lineType=8, bool bottomLeftOrigin=false);
    ~image_ostream();

    //! Defalt operator&lt; &lt; to take everything
    template 
    image_ostream&amp; operator&lt; &lt;(const T&amp; x)
    {
        _str &lt;&lt; x;
        return *this;
    }

    // this is the type of std::cout
    typedef std::basic_ostream&lt;char, std::char_traits &gt; CoutType;

    // this is the function signature of std::endl
    typedef CoutType&amp; (*StandardEndLine)(CoutType&amp;);

    // define an operator&lt; &lt; to take in std::endl
    inline image_ostream&amp; operator&lt;&lt;(StandardEndLine  manip)
    {
        // This check allows to correctly handle endline manipulator
        if (manip == ::std::endl)
            nextLine();
        else
            manip(_str);      

        return *this;
    }

private:
    void nextLine();

private:
    Mat&amp; _img;
    Point _org;
    int _fontFace;
    double _fontScale;
    Scalar _color;
    int _thickness;
    int _lineType;
    bool _bottomLeftOrigin;

    int                _offset;
    std::stringstream _str;
};
</code></pre><p>By overloading operator&lt; &lt; this class uses std::stringstream to store the internal string buffer until the end of line is encountered. Each line of text is printed on the image and cursor position is adjusted to the next line:</p><pre><code>void image_ostream::nextLine()
{
    std::string line;
    do
    {
        std::getline(_str, line);
        
        int baseLine;
        cv::Size textSize = cv::getTextSize(line, _fontFace, _fontScale, _thickness, &amp;baseLine;);
        cv::putText(_img, line, _org + cv::Point(0, _offset), _fontFace, _fontScale, _color,_thickness, _lineType, _bottomLeftOrigin);

        _offset += textSize.height + baseLine;
    } while (!_str.eof());

    _str = std::stringstream();
}
</code></pre><p>I hope this small improvement will help you next time you will need to print a complex-formatted text on the image using OpenCV. The pull-request for this feature is here: <a href=https://github.com/Itseez/opencv/pull/313>https://github.com/Itseez/opencv/pull/313</a>.</p></div><div class=post__footer><span><a class=tag href=/tags/opencv/>opencv</a></span></div><div id=comment><h2>comments</h2><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//cvtalks.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></div></main></div><footer class="footer footer__base"><ul class=footer__list><li class=footer__item>&copy;
Eugene Khvedchenya
2022</li></ul></footer><script type=text/javascript src=/js/medium-zoom.min.9c062c557275acbaba71f0c7cd4024da3e3cc825d248bc4b2130811b0965330b.js integrity="sha256-nAYsVXJ1rLq6cfDHzUAk2j48yCXSSLxLITCBGwllMws=" crossorigin=anonymous></script>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-10687369-5","auto"),ga("send","pageview"))</script><script async src=https://www.google-analytics.com/analytics.js></script></body></html>