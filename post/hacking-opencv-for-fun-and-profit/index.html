<!doctype html><html dir=ltr lang=en data-theme class=html><head><title>Eugene Khvedchenya
|
Hacking OpenCV for fun and profit</title><meta charset=utf-8><meta name=generator content="Hugo 0.98.0"><meta name=viewport content="width=device-width,initial-scale=1,viewport-fit=cover"><meta name=author content="Eugene Khvedchenya"><meta name=description content="A personal blog about Computer Vision, AI, Kaggle, Open-Source and research. You will never read this in books."><link rel=stylesheet href=/scss/main.min.b2e0cb07595e3519ab1193bb421914e06c0e26b0cc561fef23b3c6131d4d2ffa.css integrity="sha256-suDLB1leNRmrEZO7QhkU4GwOJrDMVh/vI7PGEx1NL/o=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/css/markupHighlight.min.31b0a1f317f55c529a460897848c97436bb138b19c399b37de70d463a8bf6ed5.css integrity="sha256-MbCh8xf1XFKaRgiXhIyXQ2uxOLGcOZs33nDUY6i/btU=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/fontawesome/css/fontawesome.min.7d272de35b410fb165377550cdf9c4d3a80fbbcc961e111914e4d5c0eaf5729f.css integrity="sha256-fSct41tBD7FlN3VQzfnE06gPu8yWHhEZFOTVwOr1cp8=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/fontawesome/css/solid.min.55d8333481b07a08e07cf6f37319753a2b47e99f4c395394c5747b48b495aa9b.css integrity="sha256-VdgzNIGwegjgfPbzcxl1OitH6Z9MOVOUxXR7SLSVqps=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/fontawesome/css/regular.min.a7448d02590b43449364b6b5922ed9af5410abb4de4238412a830316dedb850b.css integrity="sha256-p0SNAlkLQ0STZLa1ki7Zr1QQq7TeQjhBKoMDFt7bhQs=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/fontawesome/css/brands.min.9ed75a5d670c953fe4df935937674b4646f92674367e9e66eb995bb04e821647.css integrity="sha256-ntdaXWcMlT/k35NZN2dLRkb5JnQ2fp5m65lbsE6CFkc=" crossorigin=anonymous type=text/css><link rel="shortcut icon" href=/favicon.ico type=image/x-icon><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=canonical href=https://computer-vision-talks.com/post/hacking-opencv-for-fun-and-profit/><script type=text/javascript src=/js/anatole-header.min.f9132794301a01ff16550ed66763482bd848f62243d278f5e550229a158bfd32.js integrity="sha256-+RMnlDAaAf8WVQ7WZ2NIK9hI9iJD0nj15VAimhWL/TI=" crossorigin=anonymous></script>
<script type=text/javascript src=/js/anatole-theme-switcher.min.560a26330d27ff44a44e83b53cd07a95d4230a65930d31c5c76a8d481e5b35bf.js integrity="sha256-VgomMw0n/0SkToO1PNB6ldQjCmWTDTHFx2qNSB5bNb8=" crossorigin=anonymous></script><meta name=twitter:card content="summary"><meta name=twitter:title content="Hacking OpenCV for fun and profit"><meta name=twitter:description content="This post convers very specific but important topic about writing memory-efficient code. I will show you how to collect and analyze memory allocations that happens in OpenCV.
When it comes to writing efficient code we usually care about CPU-efficiency. However there are many times, when memory-efficiency is more important. A limited amount of RAM is not so rare as one can think. On iOS and Android there are a strict memory usage restrictions, and of your app uses more memory than allowed your app can get killed by the system."><meta property="og:title" content="Hacking OpenCV for fun and profit"><meta property="og:description" content="This post convers very specific but important topic about writing memory-efficient code. I will show you how to collect and analyze memory allocations that happens in OpenCV.
When it comes to writing efficient code we usually care about CPU-efficiency. However there are many times, when memory-efficiency is more important. A limited amount of RAM is not so rare as one can think. On iOS and Android there are a strict memory usage restrictions, and of your app uses more memory than allowed your app can get killed by the system."><meta property="og:type" content="article"><meta property="og:url" content="https://computer-vision-talks.com/post/hacking-opencv-for-fun-and-profit/"><meta property="article:section" content="post"><meta property="article:published_time" content="2014-12-25T00:00:00+00:00"><meta property="article:modified_time" content="2014-12-25T00:00:00+00:00"><meta property="og:site_name" content="Computer Vision Talks"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","articleSection":"post","name":"Hacking OpenCV for fun and profit","headline":"Hacking OpenCV for fun and profit","alternativeHeadline":"","description":"
      
        This post convers very specific but important topic about writing memory-efficient code. I will show you how to collect and analyze memory allocations that happens in OpenCV.\nWhen it comes to writing efficient code we usually care about CPU-efficiency. However there are many times, when memory-efficiency is more important. A limited amount of RAM is not so rare as one can think. On iOS and Android there are a strict memory usage restrictions, and of your app uses more memory than allowed your app can get killed by the system.


      


    ","inLanguage":"en-us","isFamilyFriendly":"true","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/computer-vision-talks.com\/post\/hacking-opencv-for-fun-and-profit\/"},"author":{"@type":"Person","name":"Eugene Khvedchenya"},"creator":{"@type":"Person","name":"Eugene Khvedchenya"},"accountablePerson":{"@type":"Person","name":"Eugene Khvedchenya"},"copyrightHolder":{"@type":"Person","name":"Eugene Khvedchenya"},"copyrightYear":"2014","dateCreated":"2014-12-25T00:00:00.00Z","datePublished":"2014-12-25T00:00:00.00Z","dateModified":"2014-12-25T00:00:00.00Z","publisher":{"@type":"Organization","name":"Eugene Khvedchenya","url":"https://computer-vision-talks.com/","logo":{"@type":"ImageObject","url":"https:\/\/computer-vision-talks.com\/favicon-32x32.png","width":"32","height":"32"}},"image":[],"url":"https:\/\/computer-vision-talks.com\/post\/hacking-opencv-for-fun-and-profit\/","wordCount":"1074","genre":[],"keywords":["opencv"]}</script></head><body class="body theme--light"><div class=wrapper><aside class=wrapper__sidebar><div class="sidebar
animated fadeInDown"><div class=sidebar__content><div class=sidebar__introduction><img class=sidebar__introduction-profileimage src=/images/4ECfkGJr_400x400.jpg alt="profile picture"><div class=sidebar__introduction-title><a href=/>Computer Vision Talks</a></div><div class=sidebar__introduction-description><p>A personal blog about Computer Vision, AI, Kaggle, Open-Source and research. You will never read this in books.</p></div></div><ul class=sidebar__list><li class=sidebar__list-item><a href=https://www.linkedin.com/in/cvtalks/ target=_blank rel=noopener aria-label=Linkedin title=Linkedin><i class="fab fa-linkedin fa-2x" aria-hidden=true></i></a></li><li class=sidebar__list-item><a href=https://twitter.com/cvtalks target=_blank rel=noopener aria-label=Twitter title=Twitter><i class="fab fa-twitter fa-2x" aria-hidden=true></i></a></li><li class=sidebar__list-item><a href=https://github.com/BloodAxe target=_blank rel=noopener aria-label=GitHub title=GitHub><i class="fab fa-github fa-2x" aria-hidden=true></i></a></li><li class=sidebar__list-item><a href=mailto:ekhvedchenya@computer-vision-talks.com target=_blank rel=noopener aria-label=E-Mail title=E-Mail><i class="fas fa-envelope fa-2x" aria-hidden=true></i></a></li></ul></div><footer class="footer footer__sidebar"><ul class=footer__list><li class=footer__item>&copy;
Eugene Khvedchenya
2022</li></ul></footer><script type=text/javascript src=/js/medium-zoom.min.9c062c557275acbaba71f0c7cd4024da3e3cc825d248bc4b2130811b0965330b.js integrity="sha256-nAYsVXJ1rLq6cfDHzUAk2j48yCXSSLxLITCBGwllMws=" crossorigin=anonymous></script>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-10687369-5","auto"),ga("send","pageview"))</script><script async src=https://www.google-analytics.com/analytics.js></script></div></aside><main class=wrapper__main><header class=header><div class="animated fadeInDown"><a role=button class=navbar-burger data-target=navMenu aria-label=menu aria-expanded=false><span aria-hidden=true class=navbar-burger__line></span>
<span aria-hidden=true class=navbar-burger__line></span>
<span aria-hidden=true class=navbar-burger__line></span></a><nav class=nav><ul class=nav__list id=navMenu><li class=nav__list-item><a href=/ title>Home</a></li><li class=nav__list-item><a href=/post/ title>Posts</a></li><li class=nav__list-item><a href=/open-source title>Open-Source</a></li><li class=nav__list-item><a href=/challenges title>Wins</a></li><li class=nav__list-item><a href=/publications title>Publications</a></li></ul><ul class="nav__list nav__list--end"><li class=nav__list-item><div class=themeswitch><a title="Switch Theme"><i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></li></ul></nav></div></header><div class="post
animated fadeInDown"><div class=post__content><h1>Hacking OpenCV for Fun and Profit</h1><ul class=post__meta><li class=post__meta-item><em class="fas fa-calendar-day post__meta-icon"></em>
<span class=post__meta-text>Thu, Dec 25, 2014</span></li><li class=post__meta-item><em class="fas fa-stopwatch post__meta-icon"></em>
<span class=post__meta-text>6-minute read</span></li></ul><p>This post convers very specific but important topic about writing memory-efficient code.
I will show you how to collect and analyze memory allocations that happens in OpenCV.</p><p>When it comes to writing efficient code we usually care about CPU-efficiency. However there are
many times, when memory-efficiency is more important. A limited amount of RAM is not so rare as
one can think. On iOS and Android there are a strict memory usage restrictions, and of your app
uses more memory than allowed your app can get killed by the system. Embedded hardware systems
used in IoT, Raspberri Pi and others also have very limited amount of RAM. So you should be very
careful when porting code from desktop with gigabytes of memory to mobile platform.</p><p></p><h2 id=why-memory-matters>Why memory matters</h2><p>Let&rsquo;s start with a small example of <a href=https://en.wikipedia.org/wiki/Unsharp_masking>unsharp masking</a> to illustrate the problem:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>cv</span><span class=o>::</span><span class=n>Mat</span> <span class=n>source</span><span class=p>,</span> <span class=n>gray</span><span class=p>,</span> <span class=n>grayFloat</span><span class=p>,</span> <span class=n>blurred</span><span class=p>,</span> <span class=n>unsharped</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>source</span> <span class=o>=</span> <span class=n>cv</span><span class=o>::</span><span class=n>imread</span><span class=p>(</span><span class=s>&#34;/some/path/to/image.png&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>cv</span><span class=o>::</span><span class=n>cvtColor</span><span class=p>(</span><span class=n>m</span><span class=p>,</span> <span class=n>gray</span><span class=p>,</span> <span class=n>cv</span><span class=o>::</span><span class=n>COLOR_BGR2GRAY</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>gray</span><span class=p>.</span><span class=n>convertTo</span><span class=p>(</span><span class=n>grayFloat</span><span class=p>,</span> <span class=n>CV_32F</span><span class=p>,</span> <span class=mf>1.0</span> <span class=o>/</span> <span class=mf>255.0</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>cv</span><span class=o>::</span><span class=n>GaussianBlur</span><span class=p>(</span><span class=n>grayFloat</span><span class=p>,</span> <span class=n>blurred</span><span class=p>,</span> <span class=n>cv</span><span class=o>::</span><span class=n>Size</span><span class=p>(</span><span class=mi>3</span><span class=p>,</span><span class=mi>3</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=n>unsharped</span> <span class=o>=</span> <span class=n>blurred</span> <span class=o>*</span> <span class=mf>1.5f</span> <span class=o>-</span> <span class=n>grayFloat</span> <span class=o>*</span> <span class=mf>0.5f</span><span class=p>;</span>
</span></span></code></pre></div><p>How much additional memory required for this piece of code to work? Let&rsquo;s count:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>source</span> <span class=o>=</span> <span class=n>cv</span><span class=o>::</span><span class=n>imread</span><span class=p>(</span><span class=s>&#34;/some/path/to/image.png&#34;</span><span class=p>);</span>         <span class=c1>// N*M*3 bytes
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>cv</span><span class=o>::</span><span class=n>cvtColor</span><span class=p>(</span><span class=n>m</span><span class=p>,</span> <span class=n>gray</span><span class=p>,</span> <span class=n>cv</span><span class=o>::</span><span class=n>COLOR_BGR2GRAY</span><span class=p>)</span>               <span class=c1>// N*M bytes
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>gray</span><span class=p>.</span><span class=n>convertTo</span><span class=p>(</span><span class=n>grayFloat</span><span class=p>,</span> <span class=n>CV_32F</span><span class=p>,</span> <span class=mf>1.0</span> <span class=o>/</span> <span class=mf>255.0</span><span class=p>);</span>         <span class=c1>// N*M*4
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>cv</span><span class=o>::</span><span class=n>GaussianBlur</span><span class=p>(</span><span class=n>grayFloat</span><span class=p>,</span> <span class=n>blurred</span><span class=p>,</span> <span class=n>cv</span><span class=o>::</span><span class=n>Size</span><span class=p>(</span><span class=mi>3</span><span class=p>,</span><span class=mi>3</span><span class=p>));</span>    <span class=c1>// N*M*4
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>unsharped</span> <span class=o>=</span> <span class=n>blurred</span> <span class=o>*</span> <span class=mf>1.5f</span> <span class=o>-</span> <span class=n>grayFloat</span> <span class=o>*</span> <span class=mf>0.5f</span><span class=p>;</span>          <span class=c1>// N*M*4   (in the best case)
</span></span></span><span class=line><span class=cl><span class=c1></span>                                                        <span class=c1>// N*M*4*3 (in the worst case)
</span></span></span></code></pre></div><p>For NxM sized image we require at least sixteen (16!) times more memory in temporary variables.
Funny, but the code looks harmless for the first look. Now you can think what will happen if you
put this snippet into iOS application. Pictures made with iPhone 5S are about 3200x2400 pixels.
On such image this code will allocate 128Mb of memory!</p><p>I will leave it for you as a home-work to figure out a solution to minimize memory usage by this function.
In this post I want to demonstrate how to measure memory usage in OpenCV automatically. Complex projects are
harder to analyze like example above, so you definitely not going to re-calculate it after each change.</p><h2 id=hacking-opencv>Hacking OpenCV</h2><p>Typically, when it comes to memory allocation tracing, we usually overload <code>new operator</code> to intercept all
allocations. In OpenCV it becomes even easier. There is a <code>cv::fastMalloc</code> function that is a memory allocator for
all OpenCV project. This means every <code>cv::Mat</code> allocation use it. So our goal is to change cv::fastMalloc to &lsquo;save&rsquo;
allocations somewhere where we can access it in runtime.</p><p>To serve this purpose, I will write a helper class to store allocations/deallocations data. For analysys purposes,
it records peak memory usage, allocations count, current memory usage and number of live objects:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// modules\core\include\opencv2\core.hpp
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=nc>CV_EXPORTS</span> <span class=n>MemorySnapshot</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>//! Total amount of allocated memory.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>size_t</span> <span class=n>allocatedMemory</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>//! Maximum amount of allocated memory for the whole time.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>size_t</span> <span class=n>peakMemoryUsage</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>//! Maximum amount of allocated memory since last snapshot.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>size_t</span> <span class=n>peakMemoryUsageSinceLastSnapshot</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>//! Number of memory allocations count for the whole program running time.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>size_t</span> <span class=n>allocationsCount</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>//! Number of memory deallocations for the whole program running time.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>size_t</span> <span class=n>deallocationsCount</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>//! Number of allocated objects that are still live (e.g not deallocated).
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>size_t</span> <span class=n>liveObjects</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>CV_EXPORTS</span> <span class=n>MemorySnapshot</span> <span class=nf>memorySnapshot</span><span class=p>();</span>
</span></span></code></pre></div><p>An implementation of <code>MemoryManager</code> is very trivial and can be extended to collect statistics on individual allocations.
However for my needs this implementation was more than enough:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// modules\core\alloc.cpp
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>MemoryManager</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=c1>//! Key - pointer to allocated memory, Value - it&#39;s size
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>typedef</span> <span class=n>std</span><span class=o>::</span><span class=n>map</span><span class=o>&lt;</span><span class=kt>void</span><span class=o>*</span><span class=p>,</span> <span class=n>size_t</span><span class=o>&gt;</span>     <span class=n>AllocationTable</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>typedef</span> <span class=n>std</span><span class=o>::</span><span class=n>lock_guard</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>mutex</span><span class=o>&gt;</span> <span class=n>LockType</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>recordAlloc</span><span class=p>(</span><span class=kt>void</span><span class=o>*</span> <span class=n>ptr</span><span class=p>,</span> <span class=n>size_t</span> <span class=n>size</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>LockType</span> <span class=n>guard</span><span class=p>(</span><span class=n>mAllocMutex</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>mAllocatedMemory</span><span class=p>.</span><span class=n>insert</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>make_pair</span><span class=p>(</span><span class=n>ptr</span><span class=p>,</span> <span class=n>size</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>mCurrentMemoryUsage</span> <span class=o>+=</span> <span class=n>size</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>mPeakMemoryUsage</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>max</span><span class=p>(</span><span class=n>mPeakMemoryUsage</span><span class=p>,</span> <span class=n>mCurrentMemoryUsage</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>mPeakMemoryUsageSinceLastSnapshot</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>max</span><span class=p>(</span><span class=n>mPeakMemoryUsageSinceLastSnapshot</span><span class=p>,</span> <span class=n>mCurrentMemoryUsage</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>mAllocationsCount</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>recordFree</span><span class=p>(</span><span class=kt>void</span><span class=o>*</span> <span class=n>ptr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>LockType</span> <span class=n>guard</span><span class=p>(</span><span class=n>mAllocMutex</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>auto</span> <span class=n>block</span> <span class=o>=</span> <span class=n>mAllocatedMemory</span><span class=p>.</span><span class=n>find</span><span class=p>(</span><span class=n>ptr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>CV_Assert</span><span class=p>(</span><span class=n>block</span> <span class=o>!=</span> <span class=n>mAllocatedMemory</span><span class=p>.</span><span class=n>end</span><span class=p>());</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>        <span class=n>mCurrentMemoryUsage</span> <span class=o>-=</span> <span class=n>block</span><span class=o>-&gt;</span><span class=n>second</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>mDeallocationsCount</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>mAllocatedMemory</span><span class=p>.</span><span class=n>erase</span><span class=p>(</span><span class=n>block</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>   
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=n>MemoryManager</span><span class=o>&amp;</span> <span class=n>Instance</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>call_once</span><span class=p>(</span><span class=n>mInitFlag</span><span class=p>,</span> <span class=p>[]()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>mInstance</span> <span class=o>==</span> <span class=k>nullptr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>mInstance</span> <span class=o>=</span> <span class=k>new</span> <span class=n>MemoryManager</span><span class=p>();</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>});</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=o>*</span><span class=n>mInstance</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>MemorySnapshot</span> <span class=nf>makeSnapshot</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>LockType</span> <span class=n>guard</span><span class=p>(</span><span class=n>mAllocMutex</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=n>MemorySnapshot</span> <span class=n>snapshot</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>snapshot</span><span class=p>.</span><span class=n>peakMemoryUsage</span> <span class=o>=</span> <span class=n>mPeakMemoryUsage</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>snapshot</span><span class=p>.</span><span class=n>peakMemoryUsageSinceLastSnapshot</span> <span class=o>=</span> <span class=n>mPeakMemoryUsageSinceLastSnapshot</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>snapshot</span><span class=p>.</span><span class=n>allocatedMemory</span> <span class=o>=</span> <span class=n>mCurrentMemoryUsage</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>snapshot</span><span class=p>.</span><span class=n>allocationsCount</span> <span class=o>=</span> <span class=n>mAllocationsCount</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>snapshot</span><span class=p>.</span><span class=n>deallocationsCount</span> <span class=o>=</span> <span class=n>mDeallocationsCount</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>snapshot</span><span class=p>.</span><span class=n>liveObjects</span> <span class=o>=</span> <span class=n>mAllocationsCount</span> <span class=o>-</span> <span class=n>mDeallocationsCount</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=n>mPeakMemoryUsageSinceLastSnapshot</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>std</span><span class=o>::</span><span class=n>move</span><span class=p>(</span><span class=n>snapshot</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>MemoryManager</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=o>:</span> <span class=n>mCurrentMemoryUsage</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>,</span> <span class=n>mPeakMemoryUsage</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>,</span> <span class=n>mPeakMemoryUsageSinceLastSnapshot</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>,</span> <span class=n>mAllocationsCount</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>,</span> <span class=n>mDeallocationsCount</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>mutex</span>      <span class=n>mAllocMutex</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>AllocationTable</span> <span class=n>mAllocatedMemory</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>size_t</span>          <span class=n>mCurrentMemoryUsage</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>size_t</span>          <span class=n>mPeakMemoryUsage</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>size_t</span>          <span class=n>mPeakMemoryUsageSinceLastSnapshot</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>size_t</span>          <span class=n>mAllocationsCount</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>size_t</span>          <span class=n>mDeallocationsCount</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=n>std</span><span class=o>::</span><span class=n>once_flag</span>  <span class=n>mInitFlag</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=n>MemoryManager</span> <span class=o>*</span> <span class=n>mInstance</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>Now it&rsquo;s time to inject our MemoryManager into <code>cv::fastAlloc</code> / <code>cv::fastFree</code> functions and create new function <code>cv::memorySnaphot</code> to retrieve memory snapshots:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// modules\core\alloc.cpp
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span><span class=o>*</span> <span class=nf>fastMalloc</span><span class=p>(</span> <span class=n>size_t</span> <span class=n>size</span> <span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>uchar</span><span class=o>*</span> <span class=n>udata</span> <span class=o>=</span> <span class=p>(</span><span class=n>uchar</span><span class=o>*</span><span class=p>)</span><span class=n>malloc</span><span class=p>(</span><span class=n>size</span> <span class=o>+</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>void</span><span class=o>*</span><span class=p>)</span> <span class=o>+</span> <span class=n>CV_MALLOC_ALIGN</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=o>!</span><span class=n>udata</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>OutOfMemoryError</span><span class=p>(</span><span class=n>size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>MemoryManager</span><span class=o>::</span><span class=n>Instance</span><span class=p>().</span><span class=n>recordAlloc</span><span class=p>(</span><span class=n>udata</span><span class=p>,</span> <span class=n>size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>uchar</span><span class=o>**</span> <span class=n>adata</span> <span class=o>=</span> <span class=n>alignPtr</span><span class=p>((</span><span class=n>uchar</span><span class=o>**</span><span class=p>)</span><span class=n>udata</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=n>CV_MALLOC_ALIGN</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>adata</span><span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=n>udata</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>adata</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>fastFree</span><span class=p>(</span><span class=kt>void</span><span class=o>*</span> <span class=n>ptr</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>ptr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>uchar</span><span class=o>*</span> <span class=n>udata</span> <span class=o>=</span> <span class=p>((</span><span class=n>uchar</span><span class=o>**</span><span class=p>)</span><span class=n>ptr</span><span class=p>)[</span><span class=o>-</span><span class=mi>1</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=n>CV_DbgAssert</span><span class=p>(</span><span class=n>udata</span> <span class=o>&lt;</span> <span class=p>(</span><span class=n>uchar</span><span class=o>*</span><span class=p>)</span><span class=n>ptr</span> <span class=o>&amp;&amp;</span>
</span></span><span class=line><span class=cl>               <span class=p>((</span><span class=n>uchar</span><span class=o>*</span><span class=p>)</span><span class=n>ptr</span> <span class=o>-</span> <span class=n>udata</span><span class=p>)</span> <span class=o>&lt;=</span> <span class=p>(</span><span class=n>ptrdiff_t</span><span class=p>)(</span><span class=k>sizeof</span><span class=p>(</span><span class=kt>void</span><span class=o>*</span><span class=p>)</span><span class=o>+</span><span class=n>CV_MALLOC_ALIGN</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>MemoryManager</span><span class=o>::</span><span class=n>Instance</span><span class=p>().</span><span class=n>recordFree</span><span class=p>(</span><span class=n>udata</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>free</span><span class=p>(</span><span class=n>udata</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>MemorySnapshot</span> <span class=nf>memorySnapshot</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>std</span><span class=o>::</span><span class=n>move</span><span class=p>(</span><span class=n>MemoryManager</span><span class=o>::</span><span class=n>Instance</span><span class=p>().</span><span class=n>makeSnapshot</span><span class=p>());</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>That&rsquo;s all with hacking OpenCV. One last step is to rebuild OpenCV with any C++11 conformant compiler and we can use memory manager for analyzing our code.</p><h2 id=fun--profit>Fun & Profit</h2><p>Back to first example, we want to measure memory usage after each step. Here&rsquo;s how C++ macros can help us:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>cv</span><span class=o>::</span><span class=n>Mat</span> <span class=n>source</span><span class=p>,</span> <span class=n>gray</span><span class=p>,</span> <span class=n>grayFloat</span><span class=p>,</span> <span class=n>blurred</span><span class=p>,</span> <span class=n>unsharped</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>MEASURE_MEMORY</span><span class=p>(</span><span class=n>m</span> <span class=o>=</span> <span class=n>cv</span><span class=o>::</span><span class=n>imread</span><span class=p>(</span><span class=s>&#34;/some/path/to/image.png&#34;</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=n>MEASURE_MEMORY</span><span class=p>(</span><span class=n>cv</span><span class=o>::</span><span class=n>cvtColor</span><span class=p>(</span><span class=n>m</span><span class=p>,</span> <span class=n>gray</span><span class=p>,</span> <span class=n>cv</span><span class=o>::</span><span class=n>COLOR_BGR2GRAY</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=n>MEASURE_MEMORY</span><span class=p>(</span><span class=n>gray</span><span class=p>.</span><span class=n>convertTo</span><span class=p>(</span><span class=n>grayFloat</span><span class=p>,</span> <span class=n>CV_32F</span><span class=p>,</span> <span class=mf>1.0</span> <span class=o>/</span> <span class=mf>255.0</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=n>MEASURE_MEMORY</span><span class=p>(</span><span class=n>cv</span><span class=o>::</span><span class=n>GaussianBlur</span><span class=p>(</span><span class=n>grayFloat</span><span class=p>,</span> <span class=n>blurred</span><span class=p>,</span> <span class=n>cv</span><span class=o>::</span><span class=n>Size</span><span class=p>(</span><span class=mi>5</span><span class=p>,</span> <span class=mi>5</span><span class=p>),</span> <span class=mi>5</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=n>MEASURE_MEMORY</span><span class=p>(</span><span class=n>unsharped</span> <span class=o>=</span> <span class=n>blurred</span> <span class=o>*</span> <span class=mf>1.5f</span> <span class=o>-</span> <span class=n>grayFloat</span> <span class=o>*</span> <span class=mf>0.5f</span><span class=p>);</span>
</span></span></code></pre></div><p>Where <code>MEASURE_MEMORY</code> is a helper macro defined as follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#define MEASURE_MEMORY(x) { size_t memOnStart = cv::memorySnapshot().allocatedMemory; x; \
</span></span></span><span class=line><span class=cl><span class=cp>                            size_t memOnEnd = cv::memorySnapshot().allocatedMemory;      \
</span></span></span><span class=line><span class=cl><span class=cp>                            std::cout &lt;&lt; #x &lt;&lt; &#34;\t&#34; &lt;&lt; memOnStart &lt;&lt; &#34;/&#34; &lt;&lt; memOnEnd &lt;&lt; std::endl; }
</span></span></span></code></pre></div><p>Example output is the following (The image was 3200x2400):</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>m</span> <span class=o>=</span> <span class=n>cv</span><span class=o>::</span><span class=n>imread</span><span class=p>(</span><span class=s>&#34;/some/path/to/image.png&#34;</span><span class=p>)</span>               <span class=c1>//      743/ 23971559 +23Mb
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>cv</span><span class=o>::</span><span class=n>cvtColor</span><span class=p>(</span><span class=n>m</span><span class=p>,</span> <span class=n>gray</span><span class=p>,</span> <span class=n>cv</span><span class=o>::</span><span class=n>COLOR_BGR2GRAY</span><span class=p>)</span>               <span class=c1>// 23971559/ 31961831 +7.6Mb
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>gray</span><span class=p>.</span><span class=n>convertTo</span><span class=p>(</span><span class=n>grayFloat</span><span class=p>,</span> <span class=n>CV_32F</span><span class=p>,</span> <span class=mf>1.0</span> <span class=o>/</span> <span class=mf>255.0</span><span class=p>)</span>          <span class=c1>// 31961831/ 63922919 +30Mb
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>cv</span><span class=o>::</span><span class=n>GaussianBlur</span><span class=p>(</span><span class=n>grayFloat</span><span class=p>,</span> <span class=n>blurred</span><span class=p>,</span> <span class=n>cv</span><span class=o>::</span><span class=n>Size</span><span class=p>(</span><span class=mi>5</span><span class=p>,</span> <span class=mi>5</span><span class=p>),</span> <span class=mi>5</span><span class=p>)</span> <span class=c1>// 63922919/ 95884007 +30Mb
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>unsharped</span> <span class=o>=</span> <span class=n>blurred</span> <span class=o>*</span> <span class=mf>1.5f</span> <span class=o>-</span> <span class=n>grayFloat</span> <span class=o>*</span> <span class=mf>0.5f</span>           <span class=c1>// 95884007/127845095 +30Mb
</span></span></span></code></pre></div><p>As you can see, numbers are really close to predicted. This way you can measure memory usage, peak usage,
number of allocations in your program easily, spot memory-related issues and fix them before they appear on
customer&rsquo;s hardware.</p><h2 id=source-code>Source code</h2><p>The modified OpenCV source code can be found here: <a href=https://github.com/BloodAxe/opencv/tree/memory-snapshots>https://github.com/BloodAxe/opencv/tree/memory-snapshots</a>. Don&rsquo;t forget to enable it by building OpenCV with ENABLE_MEMORY_SNAPSHOTS=YES option.</p><p>I have sent pull-request to OpenCV team, so there is a chance it will be included into official OpenCV. Let&rsquo;s keep fingers crossed.</p><h2 id=license>License</h2><p>The code is available for use any commercial and non-commercial purposes, but please keep a credit by providing a
link to my website <a href=http://computer-vision-talks.com>computer-vision-talks.com</a> and email <a href=ekhvedchenya@gmail.com>ekhvedchenya@gmail.com</a>.</p></div><div class=post__footer><span><a class=tag href=/tags/opencv/>opencv</a></span></div><div id=comment><h2>comments</h2><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//cvtalks.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></div></main></div><footer class="footer footer__base"><ul class=footer__list><li class=footer__item>&copy;
Eugene Khvedchenya
2022</li></ul></footer><script type=text/javascript src=/js/medium-zoom.min.9c062c557275acbaba71f0c7cd4024da3e3cc825d248bc4b2130811b0965330b.js integrity="sha256-nAYsVXJ1rLq6cfDHzUAk2j48yCXSSLxLITCBGwllMws=" crossorigin=anonymous></script>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-10687369-5","auto"),ga("send","pageview"))</script><script async src=https://www.google-analytics.com/analytics.js></script></body></html>