<!doctype html><html dir=ltr lang=en data-theme class=html><head><title>Eugene Khvedchenya
|
Mapping data from Eigen to OpenCV and back</title><meta charset=utf-8><meta name=generator content="Hugo 0.98.0"><meta name=viewport content="width=device-width,initial-scale=1,viewport-fit=cover"><meta name=author content="Eugene Khvedchenya"><meta name=description content="A personal blog about Computer Vision, AI, Kaggle, Open-Source and research. You will never read this in books."><link rel=stylesheet href=/scss/main.min.b2e0cb07595e3519ab1193bb421914e06c0e26b0cc561fef23b3c6131d4d2ffa.css integrity="sha256-suDLB1leNRmrEZO7QhkU4GwOJrDMVh/vI7PGEx1NL/o=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/css/markupHighlight.min.31b0a1f317f55c529a460897848c97436bb138b19c399b37de70d463a8bf6ed5.css integrity="sha256-MbCh8xf1XFKaRgiXhIyXQ2uxOLGcOZs33nDUY6i/btU=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/fontawesome/css/fontawesome.min.7d272de35b410fb165377550cdf9c4d3a80fbbcc961e111914e4d5c0eaf5729f.css integrity="sha256-fSct41tBD7FlN3VQzfnE06gPu8yWHhEZFOTVwOr1cp8=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/fontawesome/css/solid.min.55d8333481b07a08e07cf6f37319753a2b47e99f4c395394c5747b48b495aa9b.css integrity="sha256-VdgzNIGwegjgfPbzcxl1OitH6Z9MOVOUxXR7SLSVqps=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/fontawesome/css/regular.min.a7448d02590b43449364b6b5922ed9af5410abb4de4238412a830316dedb850b.css integrity="sha256-p0SNAlkLQ0STZLa1ki7Zr1QQq7TeQjhBKoMDFt7bhQs=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/fontawesome/css/brands.min.9ed75a5d670c953fe4df935937674b4646f92674367e9e66eb995bb04e821647.css integrity="sha256-ntdaXWcMlT/k35NZN2dLRkb5JnQ2fp5m65lbsE6CFkc=" crossorigin=anonymous type=text/css><link rel="shortcut icon" href=/favicon.ico type=image/x-icon><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=canonical href=https://computer-vision-talks.com/post/mapping-eigen-to-opencv/><script type=text/javascript src=/js/anatole-header.min.f9132794301a01ff16550ed66763482bd848f62243d278f5e550229a158bfd32.js integrity="sha256-+RMnlDAaAf8WVQ7WZ2NIK9hI9iJD0nj15VAimhWL/TI=" crossorigin=anonymous></script>
<script type=text/javascript src=/js/anatole-theme-switcher.min.560a26330d27ff44a44e83b53cd07a95d4230a65930d31c5c76a8d481e5b35bf.js integrity="sha256-VgomMw0n/0SkToO1PNB6ldQjCmWTDTHFx2qNSB5bNb8=" crossorigin=anonymous></script><meta name=twitter:card content="summary"><meta name=twitter:title content="Mapping data from Eigen to OpenCV and back"><meta name=twitter:description content="Eigen is a C++ template library for matrix and vector operations. It is highly optimized for numeric operations and support vectorization and use aligned memory allocators.
When it comes to matrix operations, Eigen is much faster than OpenCV. However, it can be situations when it is necessary to pass Eigen data to OpenCV functions.
In this post I will show how to map Eigen data to OpenCV with easy and efficient way."><meta property="og:title" content="Mapping data from Eigen to OpenCV and back"><meta property="og:description" content="Eigen is a C++ template library for matrix and vector operations. It is highly optimized for numeric operations and support vectorization and use aligned memory allocators.
When it comes to matrix operations, Eigen is much faster than OpenCV. However, it can be situations when it is necessary to pass Eigen data to OpenCV functions.
In this post I will show how to map Eigen data to OpenCV with easy and efficient way."><meta property="og:type" content="article"><meta property="og:url" content="https://computer-vision-talks.com/post/mapping-eigen-to-opencv/"><meta property="article:section" content="post"><meta property="article:published_time" content="2014-08-16T00:00:00+00:00"><meta property="article:modified_time" content="2014-08-16T00:00:00+00:00"><meta property="og:site_name" content="Computer Vision Talks"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","articleSection":"post","name":"Mapping data from Eigen to OpenCV and back","headline":"Mapping data from Eigen to OpenCV and back","alternativeHeadline":"","description":"
      
        Eigen is a C\u002b\u002b template library for matrix and vector operations. It is highly optimized for numeric operations and support vectorization and use aligned memory allocators.\nWhen it comes to matrix operations, Eigen is much faster than OpenCV. However, it can be situations when it is necessary to pass Eigen data to OpenCV functions.\nIn this post I will show how to map Eigen data to OpenCV with easy and efficient way.


      


    ","inLanguage":"en-us","isFamilyFriendly":"true","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/computer-vision-talks.com\/post\/mapping-eigen-to-opencv\/"},"author":{"@type":"Person","name":"Eugene Khvedchenya"},"creator":{"@type":"Person","name":"Eugene Khvedchenya"},"accountablePerson":{"@type":"Person","name":"Eugene Khvedchenya"},"copyrightHolder":{"@type":"Person","name":"Eugene Khvedchenya"},"copyrightYear":"2014","dateCreated":"2014-08-16T00:00:00.00Z","datePublished":"2014-08-16T00:00:00.00Z","dateModified":"2014-08-16T00:00:00.00Z","publisher":{"@type":"Organization","name":"Eugene Khvedchenya","url":"https://computer-vision-talks.com/","logo":{"@type":"ImageObject","url":"https:\/\/computer-vision-talks.com\/favicon-32x32.png","width":"32","height":"32"}},"image":[],"url":"https:\/\/computer-vision-talks.com\/post\/mapping-eigen-to-opencv\/","wordCount":"1357","genre":[],"keywords":["opencv","tutorials"]}</script></head><body class="body theme--light"><div class=wrapper><aside class=wrapper__sidebar><div class="sidebar
animated fadeInDown"><div class=sidebar__content><div class=sidebar__introduction><img class=sidebar__introduction-profileimage src=/images/4ECfkGJr_400x400.jpg alt="profile picture"><div class=sidebar__introduction-title><a href=/>Computer Vision Talks</a></div><div class=sidebar__introduction-description><p>A personal blog about Computer Vision, AI, Kaggle, Open-Source and research. You will never read this in books.</p></div></div><ul class=sidebar__list><li class=sidebar__list-item><a href=https://www.linkedin.com/in/cvtalks/ target=_blank rel=noopener aria-label=Linkedin title=Linkedin><i class="fab fa-linkedin fa-2x" aria-hidden=true></i></a></li><li class=sidebar__list-item><a href=https://twitter.com/cvtalks target=_blank rel=noopener aria-label=Twitter title=Twitter><i class="fab fa-twitter fa-2x" aria-hidden=true></i></a></li><li class=sidebar__list-item><a href=https://github.com/BloodAxe target=_blank rel=noopener aria-label=GitHub title=GitHub><i class="fab fa-github fa-2x" aria-hidden=true></i></a></li><li class=sidebar__list-item><a href=mailto:ekhvedchenya@computer-vision-talks.com target=_blank rel=noopener aria-label=E-Mail title=E-Mail><i class="fas fa-envelope fa-2x" aria-hidden=true></i></a></li></ul></div><footer class="footer footer__sidebar"><ul class=footer__list><li class=footer__item>&copy;
Eugene Khvedchenya
2022</li></ul></footer><script type=text/javascript src=/js/medium-zoom.min.9c062c557275acbaba71f0c7cd4024da3e3cc825d248bc4b2130811b0965330b.js integrity="sha256-nAYsVXJ1rLq6cfDHzUAk2j48yCXSSLxLITCBGwllMws=" crossorigin=anonymous></script>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-10687369-5","auto"),ga("send","pageview"))</script><script async src=https://www.google-analytics.com/analytics.js></script></div></aside><main class=wrapper__main><header class=header><div class="animated fadeInDown"><a role=button class=navbar-burger data-target=navMenu aria-label=menu aria-expanded=false><span aria-hidden=true class=navbar-burger__line></span>
<span aria-hidden=true class=navbar-burger__line></span>
<span aria-hidden=true class=navbar-burger__line></span></a><nav class=nav><ul class=nav__list id=navMenu><li class=nav__list-item><a href=/ title>Home</a></li><li class=nav__list-item><a href=/post/ title>Posts</a></li><li class=nav__list-item><a href=/open-source title>Open-Source</a></li><li class=nav__list-item><a href=/challenges title>Wins</a></li><li class=nav__list-item><a href=/publications title>Publications</a></li></ul><ul class="nav__list nav__list--end"><li class=nav__list-item><div class=themeswitch><a title="Switch Theme"><i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></li></ul></nav></div></header><div class="post
animated fadeInDown"><div class=post__content><h1>Mapping Data From Eigen to OpenCV and Back</h1><ul class=post__meta><li class=post__meta-item><em class="fas fa-calendar-day post__meta-icon"></em>
<span class=post__meta-text>Sat, Aug 16, 2014</span></li><li class=post__meta-item><em class="fas fa-stopwatch post__meta-icon"></em>
<span class=post__meta-text>7-minute read</span></li></ul><p>Eigen is a C++ template library for matrix and vector operations.
It is highly optimized for numeric operations and support vectorization and
use aligned memory allocators.</p><p>When it comes to matrix operations, Eigen is much faster than OpenCV.
However, it can be situations when it is necessary to pass Eigen data
to OpenCV functions.</p><p>In this post I will show how to map Eigen data to OpenCV with easy and efficient
way. No copy, minimal overhead and maximum syntax sugar:</p><p><strong>Simple case</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>Eigen</span><span class=o>::</span><span class=n>ArrayXXd</span> <span class=n>img</span><span class=p>(</span><span class=mi>480</span><span class=p>,</span> <span class=mi>640</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=n>cv</span><span class=o>::</span><span class=n>imshow</span><span class=p>(</span><span class=s>&#34;test&#34;</span><span class=p>,</span> <span class=n>eigen2cv</span><span class=p>(</span><span class=n>img</span><span class=p>));</span>
</span></span></code></pre></div><p>Proposed approach does not limited to continuous memory layout - it support expression and blocks
as well. If given expression has to be evaluated - it will be evaluated into temporary dense storage
and then mapped to OpenCV structure:</p><p><strong>Expressions</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// Unsharp mask
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Eigen</span><span class=o>::</span><span class=n>ArrayXXd</span> <span class=n>img</span><span class=p>,</span> <span class=n>blur</span><span class=p>;</span>    
</span></span><span class=line><span class=cl><span class=n>cv</span><span class=o>::</span><span class=n>GaussianBlur</span><span class=p>(</span><span class=n>eigen2cv</span><span class=p>(</span><span class=n>img</span><span class=p>),</span> <span class=n>eigen2cv</span><span class=p>(</span><span class=n>blur</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>cv</span><span class=o>::</span><span class=n>imshow</span><span class=p>(</span><span class=s>&#34;sharpened&#34;</span><span class=p>,</span> <span class=n>eigen2cv</span><span class=p>(</span><span class=mf>1.5</span> <span class=o>*</span> <span class=n>img</span> <span class=o>-</span> <span class=mf>0.5</span> <span class=o>*</span> <span class=n>blur</span><span class=p>));</span>
</span></span></code></pre></div><h2 id=idea>Idea</h2><p>In fact, Eigen heavily use <a href=#1>C++ templates magic</a> to create expression structures with delayed evaluation and <a href=#2>type traits</a> to detect type of derived objects in compile time.
This approach gives compiler a lot of hints on actual data layout which helps to generate more efficient code.
The drawback of this - if you want to deep dive in Eigen internals be prepared to hardcore.</p><p>I will use templates as well. We will have template class <code>Eigen2CV</code> and several specializations of this class - for planar types, for blocks, for expression and so on&mldr;
In addition we will specialize this class with mutable specification which will
let us to define at compile time whether mapped object is allowed for writing or not. Awesome.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span>
</span></span><span class=line><span class=cl>    <span class=k>typename</span> <span class=n>Derived</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>    <span class=k>typename</span> <span class=n>Base</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>    <span class=k>typename</span> <span class=n>ConstPolicy</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>    <span class=k>typename</span> <span class=n>StorageKind</span> <span class=o>=</span> <span class=k>typename</span> <span class=n>Eigen</span><span class=o>::</span><span class=n>internal</span><span class=o>::</span><span class=n>traits</span><span class=o>&lt;</span><span class=n>Derived</span><span class=o>&gt;::</span><span class=n>StorageKind</span> 
</span></span><span class=line><span class=cl>    <span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Eigen2CV</span><span class=p>;</span>
</span></span></code></pre></div><p>To interact with OpenCV, we can declare implicit conversion operators for <code>cv::Mat</code>, <code>cv::InputArray</code> and <code>cv::OutputArray</code>.
Some of the mapped objects can have read/write access while the rest - read-only.
Therefore we will introduce the base class <code>Eigen2CVBase</code> to provide a &ldquo;read-only&rdquo; access for all derived objects.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Eigen2CVBase</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>operator</span> <span class=n>cv</span><span class=o>::</span><span class=n>Mat</span><span class=p>()</span> <span class=k>const</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>mBody</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>operator</span> <span class=n>cv</span><span class=o>::</span><span class=n>_InputArray</span><span class=p>()</span> <span class=k>const</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>cv</span><span class=o>::</span><span class=n>_InputArray</span><span class=p>(</span><span class=n>mBody</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl><span class=k>protected</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>Derived</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=n>mapPlaneMemory</span><span class=p>(</span><span class=k>const</span> <span class=n>Derived</span><span class=o>&amp;</span> <span class=n>src</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>const</span> <span class=kt>bool</span> <span class=n>isRowMajor</span> <span class=o>=</span> <span class=kt>int</span><span class=p>(</span><span class=n>Derived</span><span class=o>::</span><span class=n>Flags</span><span class=p>)</span> <span class=o>&amp;</span> <span class=n>Eigen</span><span class=o>::</span><span class=n>RowMajorBit</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>const</span> <span class=kt>int</span> <span class=n>stride</span> <span class=o>=</span> <span class=n>src</span><span class=p>.</span><span class=n>outerStride</span><span class=p>()</span> <span class=o>*</span> <span class=k>sizeof</span><span class=p>(</span><span class=k>typename</span> <span class=n>Derived</span><span class=o>::</span><span class=n>Scalar</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>isRowMajor</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>this</span><span class=o>-&gt;</span><span class=n>mapPlaneMemoryRowMajor</span><span class=p>(</span><span class=n>src</span><span class=p>.</span><span class=n>data</span><span class=p>(),</span>
</span></span><span class=line><span class=cl>                                         <span class=n>src</span><span class=p>.</span><span class=n>rows</span><span class=p>(),</span>
</span></span><span class=line><span class=cl>                                         <span class=n>src</span><span class=p>.</span><span class=n>cols</span><span class=p>(),</span>
</span></span><span class=line><span class=cl>                                         <span class=n>stride</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span>
</span></span><span class=line><span class=cl>            <span class=k>this</span><span class=o>-&gt;</span><span class=n>mapPlaneMemoryColMajor</span><span class=p>(</span><span class=n>src</span><span class=p>.</span><span class=n>data</span><span class=p>(),</span>
</span></span><span class=line><span class=cl>                                         <span class=n>src</span><span class=p>.</span><span class=n>rows</span><span class=p>(),</span>
</span></span><span class=line><span class=cl>                                         <span class=n>src</span><span class=p>.</span><span class=n>cols</span><span class=p>(),</span>
</span></span><span class=line><span class=cl>                                         <span class=n>stride</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>Scalar</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=n>mapPlaneMemoryRowMajor</span><span class=p>(</span><span class=k>const</span> <span class=n>Scalar</span><span class=o>*</span> <span class=n>planeData</span><span class=p>,</span> <span class=kt>int</span> <span class=n>rows</span><span class=p>,</span> <span class=kt>int</span> <span class=n>cols</span><span class=p>,</span> <span class=kt>int</span> <span class=n>stride</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=o>-&gt;</span><span class=n>mBody</span> <span class=o>=</span> <span class=n>cv</span><span class=o>::</span><span class=n>Mat</span><span class=p>(</span><span class=n>rows</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>                              <span class=n>cols</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>                              <span class=n>opencv_matrix</span><span class=o>&lt;</span><span class=n>Scalar</span><span class=o>&gt;::</span><span class=n>type</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>                              <span class=k>const_cast</span><span class=o>&lt;</span><span class=n>Scalar</span><span class=o>*&gt;</span><span class=p>(</span><span class=n>planeData</span><span class=p>),</span> 
</span></span><span class=line><span class=cl>                              <span class=n>stride</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>Scalar</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=n>mapPlaneMemoryColMajor</span><span class=p>(</span><span class=k>const</span> <span class=n>Scalar</span><span class=o>*</span> <span class=n>planeData</span><span class=p>,</span> <span class=kt>int</span> <span class=n>rows</span><span class=p>,</span> <span class=kt>int</span> <span class=n>cols</span><span class=p>,</span> <span class=kt>int</span> <span class=n>stride</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=o>-&gt;</span><span class=n>mBody</span> <span class=o>=</span> <span class=n>cv</span><span class=o>::</span><span class=n>Mat</span><span class=p>(</span><span class=n>cols</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>                              <span class=n>rows</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>                              <span class=n>opencv_matrix</span><span class=o>&lt;</span><span class=n>Scalar</span><span class=o>&gt;::</span><span class=n>type</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>                              <span class=k>const_cast</span><span class=o>&lt;</span><span class=n>Scalar</span><span class=o>*&gt;</span><span class=p>(</span><span class=n>planeData</span><span class=p>),</span> 
</span></span><span class=line><span class=cl>                              <span class=n>stride</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>Derived</span><span class=p>,</span> <span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=n>assignMatrix</span><span class=p>(</span><span class=n>Eigen</span><span class=o>::</span><span class=n>DenseBase</span><span class=o>&lt;</span><span class=n>Derived</span><span class=o>&gt;&amp;</span> <span class=n>dst</span><span class=p>,</span> <span class=k>const</span> <span class=n>cv</span><span class=o>::</span><span class=n>Mat_</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;&amp;</span> <span class=n>src</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>typedef</span> <span class=k>typename</span> <span class=n>Derived</span><span class=o>::</span><span class=n>Scalar</span> <span class=n>Scalar</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>typedef</span> <span class=n>Eigen</span><span class=o>::</span><span class=n>Matrix</span><span class=o>&lt;</span><span class=n>T</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>                              <span class=n>Eigen</span><span class=o>::</span><span class=n>Dynamic</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>                              <span class=n>Eigen</span><span class=o>::</span><span class=n>Dynamic</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>                              <span class=n>Eigen</span><span class=o>::</span><span class=n>RowMajor</span><span class=o>&gt;</span> <span class=n>PlainMatrixType</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=n>dst</span> <span class=o>=</span> <span class=n>Eigen</span><span class=o>::</span><span class=n>Map</span><span class=o>&lt;</span><span class=n>PlainMatrixType</span><span class=o>&gt;</span><span class=p>((</span><span class=n>T</span><span class=o>*</span><span class=p>)</span><span class=n>src</span><span class=p>.</span><span class=n>data</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>                                          <span class=n>src</span><span class=p>.</span><span class=n>rows</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>                                          <span class=n>src</span><span class=p>.</span><span class=n>cols</span><span class=p>).</span>
</span></span><span class=line><span class=cl>                                          <span class=k>template</span> <span class=n>cast</span><span class=o>&lt;</span><span class=n>Scalar</span><span class=o>&gt;</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>cv</span><span class=o>::</span><span class=n>Mat</span> <span class=n>mBody</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>For those Eigen types that allows read/write access, we will have additional conversion operator to cv::OutputArray. By default all derived types will have read-only access.</p><h2 id=mapping-eigen-plain-objects>Mapping Eigen plain objects</h2><p>Let&rsquo;s start from mapping continuous block of memory represented by <code>Eigen::Matrix</code> of <code>Eigen::Array</code>.
These two classes derives from <code>Eigen::PlainObjectBase</code> class which provides methods to access internal storage
buffer.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>Derived</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Eigen2CV</span><span class=o>&lt;</span>
</span></span><span class=line><span class=cl>    <span class=n>Derived</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>    <span class=n>Eigen</span><span class=o>::</span><span class=n>PlainObjectBase</span><span class=o>&lt;</span><span class=n>Derived</span><span class=o>&gt;</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>    <span class=n>details</span><span class=o>::</span><span class=n>Const</span><span class=o>&gt;</span> <span class=o>:</span> <span class=k>public</span> <span class=n>Eigen2CVBase</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>typedef</span> <span class=k>typename</span> <span class=n>Derived</span><span class=o>::</span><span class=n>Scalar</span> <span class=n>Scalar</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>typedef</span> <span class=n>Eigen2CV</span><span class=o>&lt;</span><span class=n>Derived</span><span class=p>,</span> <span class=n>Eigen</span><span class=o>::</span><span class=n>PlainObjectBase</span><span class=o>&lt;</span><span class=n>Derived</span><span class=o>&gt;</span><span class=p>,</span> <span class=n>details</span><span class=o>::</span><span class=n>Mutable</span><span class=o>&gt;</span> <span class=n>Self</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>Eigen2CV</span><span class=p>(</span><span class=k>const</span> <span class=n>Eigen</span><span class=o>::</span><span class=n>PlainObjectBase</span><span class=o>&lt;</span><span class=n>Derived</span><span class=o>&gt;&amp;</span> <span class=n>src</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=o>:</span> <span class=n>mMappedView</span><span class=p>(</span><span class=n>src</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=o>-&gt;</span><span class=n>mapPlaneMemory</span><span class=p>(</span><span class=n>mMappedView</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>           
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=n>Eigen</span><span class=o>::</span><span class=n>PlainObjectBase</span><span class=o>&lt;</span><span class=n>Derived</span><span class=o>&gt;&amp;</span> <span class=n>mMappedView</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>This is <code>Eigen2CV</code> specialization for constant <code>Eigen::PlainObjectBase</code> object. This specialization of <code>Eigen2CV</code> can return constant reference to <code>cv::Mat</code> and <code>cv::InputArray</code>.</p><p>Now we can write two overloads of <code>eigen2cv</code> function for <code>Eigen::Matrix</code> and <code>Eigen::Array</code>. The goal of <code>eigen2cv</code> is simple - take an argument and create &lsquo;right&rsquo; Eigen2CV&lt;&mldr;> mapper.
Here is how it looks like for planar data:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>E</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=n>Eigen2CV</span><span class=o>&lt;</span><span class=n>E</span><span class=p>,</span> <span class=n>Eigen</span><span class=o>::</span><span class=n>PlainObjectBase</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span><span class=p>,</span> <span class=n>details</span><span class=o>::</span><span class=n>Mutable</span><span class=o>&gt;</span> 
</span></span><span class=line><span class=cl><span class=n>eigen2cv</span><span class=p>(</span><span class=n>Eigen</span><span class=o>::</span><span class=n>PlainObjectBase</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;&amp;</span> <span class=n>src</span><span class=p>)</span> 
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>Eigen2CV</span><span class=o>&lt;</span><span class=n>E</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>                    <span class=n>Eigen</span><span class=o>::</span><span class=n>PlainObjectBase</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>                    <span class=n>details</span><span class=o>::</span><span class=n>Mutable</span>
</span></span><span class=line><span class=cl>                    <span class=o>&gt;</span><span class=p>(</span><span class=n>src</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>E</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=n>Eigen2CV</span><span class=o>&lt;</span><span class=n>E</span><span class=p>,</span> <span class=n>Eigen</span><span class=o>::</span><span class=n>PlainObjectBase</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span><span class=p>,</span> <span class=n>details</span><span class=o>::</span><span class=n>Const</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=n>eigen2cv</span><span class=p>(</span><span class=k>const</span> <span class=n>Eigen</span><span class=o>::</span><span class=n>PlainObjectBase</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;&amp;</span> <span class=n>src</span><span class=p>)</span> 
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>Eigen2CV</span><span class=o>&lt;</span><span class=n>E</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>                    <span class=n>Eigen</span><span class=o>::</span><span class=n>PlainObjectBase</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>                    <span class=n>details</span><span class=o>::</span><span class=n>Const</span>
</span></span><span class=line><span class=cl>                    <span class=o>&gt;</span><span class=p>(</span><span class=n>src</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>  
</span></span></code></pre></div><p>I want to draw your attention to how elegant C++ allows us to distinct mutable and constant objects.
Compiler will choose right function depending on the context of <code>src</code>.
In case of access right conflicts you will get compile-time error.</p><h2 id=assigning-opencv-matrix-to-eigen-object>Assigning OpenCV matrix to Eigen object</h2><p>What if someone write:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>eigen2cv</span><span class=p>(</span><span class=n>a</span><span class=p>)</span> <span class=o>=</span> <span class=n>cv</span><span class=o>::</span><span class=n>imread</span><span class=p>(</span><span class=s>&#34;lena.jpg&#34;</span><span class=p>,</span> <span class=n>cv</span><span class=o>::</span><span class=n>IMREAD_GRAYSCALE</span><span class=p>);</span>
</span></span></code></pre></div><p>Well, it&rsquo;s legal and I see no problems with this code while we follow few restrictions:</p><ol><li><code>data</code> has dynamic size or fixed one which match cv::Mat size.</li><li>Image is single channel - there is no way to map multi-channel images to Eigen now.</li></ol><p>Assignment operator is also quite simple:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=n>Self</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=n>cv</span><span class=o>::</span><span class=n>Mat_</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;&amp;</span> <span class=n>src</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>assignMatrix</span><span class=o>&lt;</span><span class=n>Derived</span><span class=p>,</span> <span class=n>T</span><span class=o>&gt;</span><span class=p>(</span><span class=n>mMappedView</span><span class=p>,</span> <span class=n>src</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>*</span><span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * @brief Assignment operator to copy OpenCV Mat data to mapped Eigen object.
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=n>Self</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span> <span class=p>(</span><span class=k>const</span> <span class=n>cv</span><span class=o>::</span><span class=n>Mat</span><span class=o>&amp;</span> <span class=n>m</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>switch</span> <span class=p>(</span><span class=n>m</span><span class=p>.</span><span class=n>type</span><span class=p>())</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=nl>CV_8U</span><span class=p>:</span>  <span class=k>return</span> <span class=o>*</span><span class=k>this</span> <span class=o>=</span> <span class=p>(</span><span class=n>cv</span><span class=o>::</span><span class=n>Mat_</span><span class=o>&lt;</span><span class=kt>uint8_t</span><span class=o>&gt;</span><span class=p>)</span><span class=n>m</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=nl>CV_16U</span><span class=p>:</span> <span class=k>return</span> <span class=o>*</span><span class=k>this</span> <span class=o>=</span> <span class=p>(</span><span class=n>cv</span><span class=o>::</span><span class=n>Mat_</span><span class=o>&lt;</span><span class=kt>uint16_t</span><span class=o>&gt;</span><span class=p>)</span><span class=n>m</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=nl>CV_16S</span><span class=p>:</span> <span class=k>return</span> <span class=o>*</span><span class=k>this</span> <span class=o>=</span> <span class=p>(</span><span class=n>cv</span><span class=o>::</span><span class=n>Mat_</span><span class=o>&lt;</span><span class=kt>int16_t</span><span class=o>&gt;</span><span class=p>)</span><span class=n>m</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=nl>CV_32S</span><span class=p>:</span> <span class=k>return</span> <span class=o>*</span><span class=k>this</span> <span class=o>=</span> <span class=p>(</span><span class=n>cv</span><span class=o>::</span><span class=n>Mat_</span><span class=o>&lt;</span><span class=kt>int32_t</span><span class=o>&gt;</span><span class=p>)</span><span class=n>m</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=nl>CV_32F</span><span class=p>:</span> <span class=k>return</span> <span class=o>*</span><span class=k>this</span> <span class=o>=</span> <span class=p>(</span><span class=n>cv</span><span class=o>::</span><span class=n>Mat_</span><span class=o>&lt;</span><span class=kt>float</span><span class=o>&gt;</span><span class=p>)</span><span class=n>m</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=nl>CV_64F</span><span class=p>:</span> <span class=k>return</span> <span class=o>*</span><span class=k>this</span> <span class=o>=</span> <span class=p>(</span><span class=n>cv</span><span class=o>::</span><span class=n>Mat_</span><span class=o>&lt;</span><span class=kt>double</span><span class=o>&gt;</span><span class=p>)</span><span class=n>m</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>default</span><span class=o>:</span>
</span></span><span class=line><span class=cl>            <span class=k>throw</span> <span class=n>std</span><span class=o>::</span><span class=n>runtime_error</span><span class=p>(</span><span class=s>&#34;Unsupported OpenCV matrix type&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=mapping-eigen-expressions>Mapping Eigen expressions</h2><p>Dealing with expressions is not much harder.
Depending on the expression type, we must either evaluate it into dense storage (when it&rsquo;s real expression like <code>AX + B</code>, or <code>cast&lt;float>()</code>)
or use underlying storage with regards to expression operator (<code>block()</code>, <code>transpose()</code>, <code>array()</code>, <code>matrix()</code>).
We will get to mapping blocks in a next section.</p><p>Let&rsquo;s map expression that require evaluation first. For the sake of simplicity,
I will not implement write expressions, e.g expressions that require eval/update/write-back.
Eigen2CV will be able map Eigen expressions in read-only mode.
And here&rsquo;s how:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>Derived</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Eigen2CV</span><span class=o>&lt;</span><span class=n>Derived</span><span class=p>,</span> <span class=n>Eigen</span><span class=o>::</span><span class=n>EigenBase</span><span class=o>&lt;</span><span class=n>Derived</span><span class=o>&gt;</span><span class=p>,</span> <span class=n>details</span><span class=o>::</span><span class=n>Const</span><span class=o>&gt;</span> <span class=o>:</span> <span class=k>public</span> <span class=n>Eigen2CVBase</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>typedef</span> <span class=k>typename</span> <span class=n>Derived</span><span class=o>::</span><span class=n>Scalar</span> <span class=n>Scalar</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>typedef</span> <span class=k>typename</span> <span class=n>Eigen</span><span class=o>::</span><span class=n>internal</span><span class=o>::</span><span class=n>plain_matrix_type</span><span class=o>&lt;</span><span class=n>Derived</span><span class=o>&gt;::</span><span class=n>type</span> <span class=n>StorageType</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>Eigen2CV</span><span class=p>(</span><span class=k>const</span> <span class=n>Eigen</span><span class=o>::</span><span class=n>EigenBase</span><span class=o>&lt;</span><span class=n>Derived</span><span class=o>&gt;&amp;</span> <span class=n>src</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>mStorage</span> <span class=o>=</span> <span class=n>src</span><span class=p>;</span> <span class=c1>// All magic happens here
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>this</span><span class=o>-&gt;</span><span class=n>mapPlaneMemory</span><span class=p>(</span><span class=n>mStorage</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>protected</span><span class=o>:</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=n>mapPlaneMemory</span><span class=p>(</span><span class=n>StorageType</span><span class=o>&amp;</span> <span class=n>src</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span> <span class=p>(</span> <span class=n>StorageType</span><span class=o>::</span><span class=n>Options</span> <span class=o>&amp;</span> <span class=n>Eigen</span><span class=o>::</span><span class=n>RowMajor</span><span class=p>)</span> <span class=o>==</span> <span class=n>Eigen</span><span class=o>::</span><span class=n>RowMajor</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>this</span><span class=o>-&gt;</span><span class=n>mapPlaneMemoryRowMajor</span><span class=p>(</span><span class=n>src</span><span class=p>.</span><span class=n>data</span><span class=p>(),</span> 
</span></span><span class=line><span class=cl>                                         <span class=n>src</span><span class=p>.</span><span class=n>rows</span><span class=p>(),</span> 
</span></span><span class=line><span class=cl>                                         <span class=n>src</span><span class=p>.</span><span class=n>cols</span><span class=p>(),</span> 
</span></span><span class=line><span class=cl>                                         <span class=n>src</span><span class=p>.</span><span class=n>outerStride</span><span class=p>()</span> <span class=o>*</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>Scalar</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span>
</span></span><span class=line><span class=cl>            <span class=k>this</span><span class=o>-&gt;</span><span class=n>mapPlaneMemoryColMajor</span><span class=p>(</span><span class=n>src</span><span class=p>.</span><span class=n>data</span><span class=p>(),</span> 
</span></span><span class=line><span class=cl>                                         <span class=n>src</span><span class=p>.</span><span class=n>rows</span><span class=p>(),</span> 
</span></span><span class=line><span class=cl>                                         <span class=n>src</span><span class=p>.</span><span class=n>cols</span><span class=p>(),</span> 
</span></span><span class=line><span class=cl>                                         <span class=n>src</span><span class=p>.</span><span class=n>outerStride</span><span class=p>()</span> <span class=o>*</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>Scalar</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>StorageType</span> <span class=n>mStorage</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>For the first look, it is almost the same as specialization for planar data types. A few differences make this specialization very other one.
First, <code>Eigen::internal::plain_matrix_type&lt;Derived>::type</code> type trait helps us to infer type of dense storage for given expression.
Second, line <code>mStorage = src</code> looks really simple right? But hold on, <code>src</code> is an expression, and <code>mStorage</code> is dense matrix.
Assignment operator makes our like much easier by performing evaluation step inside this assignment.</p><p>And here is <code>eigen2cv</code> overload for Eigen expressions:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>E</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=n>Eigen2CV</span><span class=o>&lt;</span><span class=n>E</span><span class=p>,</span> <span class=n>Eigen</span><span class=o>::</span><span class=n>EigenBase</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span><span class=p>,</span> <span class=n>details</span><span class=o>::</span><span class=n>Const</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=n>eigen2cv</span><span class=p>(</span><span class=k>const</span> <span class=n>Eigen</span><span class=o>::</span><span class=n>EigenBase</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;&amp;</span> <span class=n>src</span><span class=p>)</span> 
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>Eigen2CV</span><span class=o>&lt;</span><span class=n>E</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>                    <span class=n>Eigen</span><span class=o>::</span><span class=n>EigenBase</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>                    <span class=n>details</span><span class=o>::</span><span class=n>Const</span>
</span></span><span class=line><span class=cl>                    <span class=o>&gt;</span><span class=p>(</span><span class=n>src</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=mapping-eigen-views>Mapping Eigen views</h2><p>User can create sub-view for the Eigen storage using <code>block()</code>.
Eigen block create view that points to the same memory region, but has different size and stride.
Blocks can be read and written.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>Derived</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Eigen2CV</span><span class=o>&lt;</span><span class=n>Derived</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>               <span class=n>Eigen</span><span class=o>::</span><span class=n>Block</span><span class=o>&lt;</span><span class=n>Derived</span><span class=o>&gt;</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>               <span class=n>details</span><span class=o>::</span><span class=n>Mutable</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>               <span class=n>Eigen</span><span class=o>::</span><span class=n>Dense</span><span class=o>&gt;</span> <span class=o>:</span> <span class=k>public</span> <span class=n>Eigen2CVBase</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>typename</span> <span class=n>Derived</span><span class=o>::</span><span class=n>Scalar</span> <span class=n>Scalar</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>typedef</span> <span class=n>Eigen2CV</span><span class=o>&lt;</span><span class=n>Derived</span><span class=p>,</span> <span class=n>Eigen</span><span class=o>::</span><span class=n>Block</span><span class=o>&lt;</span><span class=n>Derived</span><span class=o>&gt;</span><span class=p>,</span> <span class=n>details</span><span class=o>::</span><span class=n>Mutable</span><span class=o>&gt;</span> <span class=n>Self</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>Eigen2CV</span><span class=p>(</span><span class=k>const</span> <span class=n>Eigen</span><span class=o>::</span><span class=n>Block</span><span class=o>&lt;</span><span class=n>Derived</span><span class=o>&gt;&amp;</span> <span class=n>src</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=o>:</span> <span class=n>mMappedView</span><span class=p>(</span><span class=n>src</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=o>-&gt;</span><span class=n>mapPlaneMemory</span><span class=p>(</span><span class=n>mMappedView</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>operator</span> <span class=n>cv</span><span class=o>::</span><span class=n>_OutputArray</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>cv</span><span class=o>::</span><span class=n>_OutputArray</span><span class=p>(</span><span class=k>this</span><span class=o>-&gt;</span><span class=n>mBody</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=n>Self</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=n>cv</span><span class=o>::</span><span class=n>Mat_</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;&amp;</span> <span class=n>src</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>MatrixAssign</span><span class=o>&lt;</span><span class=n>Derived</span><span class=p>,</span> <span class=n>T</span><span class=o>&gt;</span><span class=p>(</span><span class=n>mMappedView</span><span class=p>,</span> <span class=n>src</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=o>*</span><span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>     * @brief Assignment operator to copy OpenCV Mat data to mapped Eigen object.
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=n>Self</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span> <span class=p>(</span><span class=k>const</span> <span class=n>cv</span><span class=o>::</span><span class=n>Mat</span><span class=o>&amp;</span> <span class=n>m</span><span class=p>)</span> <span class=k>throw</span> <span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>switch</span> <span class=p>(</span><span class=n>m</span><span class=p>.</span><span class=n>type</span><span class=p>())</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>case</span> <span class=nl>CV_8U</span><span class=p>:</span>  <span class=k>return</span> <span class=o>*</span><span class=k>this</span> <span class=o>=</span> <span class=p>(</span><span class=n>cv</span><span class=o>::</span><span class=n>Mat_</span><span class=o>&lt;</span><span class=kt>uint8_t</span><span class=o>&gt;</span><span class=p>)</span><span class=n>m</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>case</span> <span class=nl>CV_16U</span><span class=p>:</span> <span class=k>return</span> <span class=o>*</span><span class=k>this</span> <span class=o>=</span> <span class=p>(</span><span class=n>cv</span><span class=o>::</span><span class=n>Mat_</span><span class=o>&lt;</span><span class=kt>uint16_t</span><span class=o>&gt;</span><span class=p>)</span><span class=n>m</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>case</span> <span class=nl>CV_16S</span><span class=p>:</span> <span class=k>return</span> <span class=o>*</span><span class=k>this</span> <span class=o>=</span> <span class=p>(</span><span class=n>cv</span><span class=o>::</span><span class=n>Mat_</span><span class=o>&lt;</span><span class=kt>int16_t</span><span class=o>&gt;</span><span class=p>)</span><span class=n>m</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>case</span> <span class=nl>CV_32S</span><span class=p>:</span> <span class=k>return</span> <span class=o>*</span><span class=k>this</span> <span class=o>=</span> <span class=p>(</span><span class=n>cv</span><span class=o>::</span><span class=n>Mat_</span><span class=o>&lt;</span><span class=kt>int32_t</span><span class=o>&gt;</span><span class=p>)</span><span class=n>m</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>case</span> <span class=nl>CV_32F</span><span class=p>:</span> <span class=k>return</span> <span class=o>*</span><span class=k>this</span> <span class=o>=</span> <span class=p>(</span><span class=n>cv</span><span class=o>::</span><span class=n>Mat_</span><span class=o>&lt;</span><span class=kt>float</span><span class=o>&gt;</span><span class=p>)</span><span class=n>m</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>case</span> <span class=nl>CV_64F</span><span class=p>:</span> <span class=k>return</span> <span class=o>*</span><span class=k>this</span> <span class=o>=</span> <span class=p>(</span><span class=n>cv</span><span class=o>::</span><span class=n>Mat_</span><span class=o>&lt;</span><span class=kt>double</span><span class=o>&gt;</span><span class=p>)</span><span class=n>m</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>default</span><span class=o>:</span>
</span></span><span class=line><span class=cl>                <span class=k>throw</span> <span class=n>std</span><span class=o>::</span><span class=n>runtime_error</span><span class=p>(</span><span class=s>&#34;Unsupported OpenCV matrix type&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=n>Eigen</span><span class=o>::</span><span class=n>Block</span><span class=o>&lt;</span><span class=n>Derived</span><span class=o>&gt;&amp;</span> <span class=n>mMappedView</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>E</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=n>Eigen2CV</span><span class=o>&lt;</span><span class=n>E</span><span class=p>,</span> <span class=n>Eigen</span><span class=o>::</span><span class=n>Block</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span><span class=p>,</span> <span class=n>details</span><span class=o>::</span><span class=n>Mutable</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=n>eigen2cv</span><span class=p>(</span><span class=k>const</span> <span class=n>Eigen</span><span class=o>::</span><span class=n>Block</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;&amp;</span> <span class=n>src</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>Eigen2CV</span><span class=o>&lt;</span><span class=n>E</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>                    <span class=n>Eigen</span><span class=o>::</span><span class=n>Block</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>                    <span class=n>details</span><span class=o>::</span><span class=n>Mutable</span>
</span></span><span class=line><span class=cl>                    <span class=o>&gt;</span><span class=p>(</span><span class=n>src</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=eigen-memory-organization>Eigen memory organization</h2><p>Eigen can use column-major or row-major ordering of internal data storage.
By default it&rsquo;s column-major, but OpenCV use row-major ordering.</p><h2 id=demonstration>Demonstration</h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>Image8u_t</span> <span class=nf>a</span><span class=p>(</span><span class=mi>512</span><span class=p>,</span> <span class=mi>512</span><span class=p>);</span> <span class=c1>// Eigen::Matrix&lt;uint8_t, Dynamic, Dynamic&gt;
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=n>size_t</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>512</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=n>size_t</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=mi>512</span><span class=p>;</span> <span class=n>j</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>a</span><span class=p>(</span><span class=n>i</span><span class=p>,</span><span class=n>j</span><span class=p>)</span> <span class=o>=</span> <span class=mf>255.0f</span> <span class=o>*</span> <span class=p>(</span><span class=n>sin</span><span class=p>(</span><span class=mf>0.04f</span> <span class=o>*</span> <span class=n>i</span><span class=p>)</span> <span class=o>*</span> <span class=n>sin</span><span class=p>(</span><span class=mf>0.04f</span> <span class=o>*</span> <span class=n>i</span><span class=p>)</span> <span class=o>+</span> 
</span></span><span class=line><span class=cl>                           <span class=n>cos</span><span class=p>(</span><span class=mf>0.04f</span> <span class=o>*</span> <span class=n>j</span><span class=p>)</span> <span class=o>*</span> <span class=n>cos</span><span class=p>(</span><span class=mf>0.04f</span> <span class=o>*</span> <span class=n>j</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>cv</span><span class=o>::</span><span class=n>GaussianBlur</span><span class=p>(</span><span class=n>eigen2cv</span><span class=p>(</span><span class=n>a</span><span class=p>.</span><span class=n>block</span><span class=p>(</span><span class=mi>128</span><span class=p>,</span> <span class=mi>128</span><span class=p>,</span> <span class=mi>256</span><span class=p>,</span> <span class=mi>256</span><span class=p>)),</span>
</span></span><span class=line><span class=cl>                 <span class=n>eigen2cv</span><span class=p>(</span><span class=n>a</span><span class=p>.</span><span class=n>block</span><span class=p>(</span><span class=mi>128</span><span class=p>,</span> <span class=mi>128</span><span class=p>,</span> <span class=mi>256</span><span class=p>,</span> <span class=mi>256</span><span class=p>)),</span> <span class=n>cv</span><span class=o>::</span><span class=n>Size</span><span class=p>(</span><span class=mi>25</span><span class=p>,</span><span class=mi>25</span><span class=p>),</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>cv</span><span class=o>::</span><span class=n>imshow</span><span class=p>(</span><span class=s>&#34;Blur image region&#34;</span><span class=p>,</span> <span class=n>eigen2cv</span><span class=p>(</span><span class=n>a</span><span class=p>));</span>
</span></span></code></pre></div><p><img src=blur_roi.png alt="Blur image region"></p><h2 id=source-code>Source code</h2><p>Source code for this post can be found on GitHub: <a href=https://gist.github.com/BloodAxe/c94d65d5977fb1d3e53f>Eigen2CV.h</a>.</p><p>License: <a href=https://tldrlegal.com/license/bsd-3-clause-license-(revised)#summary>BSD-3</a>.</p><h2 id=references>References</h2><ol><li>Modern C++ Design: Generic Programming and Design Patterns Applied</li></ol></div><div class=post__footer><span><a class=tag href=/tags/opencv/>opencv</a><a class=tag href=/tags/tutorials/>tutorials</a></span></div><div id=comment><h2>comments</h2><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//cvtalks.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></div></main></div><footer class="footer footer__base"><ul class=footer__list><li class=footer__item>&copy;
Eugene Khvedchenya
2022</li></ul></footer><script type=text/javascript src=/js/medium-zoom.min.9c062c557275acbaba71f0c7cd4024da3e3cc825d248bc4b2130811b0965330b.js integrity="sha256-nAYsVXJ1rLq6cfDHzUAk2j48yCXSSLxLITCBGwllMws=" crossorigin=anonymous></script>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-10687369-5","auto"),ga("send","pageview"))</script><script async src=https://www.google-analytics.com/analytics.js></script></body></html>