<!doctype html><html dir=ltr lang=en data-theme class=html><head><title>Eugene Khvedchenya
|
Maximizing performance of CV_BGRA2GRAY conversion using NEON and cv::parallel_for</title><meta charset=utf-8><meta name=generator content="Hugo 0.98.0"><meta name=viewport content="width=device-width,initial-scale=1,viewport-fit=cover"><meta name=author content="Eugene Khvedchenya"><meta name=description content="A personal blog about Computer Vision, AI, Kaggle, Open-Source and research. You will never read this in books."><link rel=stylesheet href=/scss/main.min.b2e0cb07595e3519ab1193bb421914e06c0e26b0cc561fef23b3c6131d4d2ffa.css integrity="sha256-suDLB1leNRmrEZO7QhkU4GwOJrDMVh/vI7PGEx1NL/o=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/css/markupHighlight.min.31b0a1f317f55c529a460897848c97436bb138b19c399b37de70d463a8bf6ed5.css integrity="sha256-MbCh8xf1XFKaRgiXhIyXQ2uxOLGcOZs33nDUY6i/btU=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/fontawesome/css/fontawesome.min.7d272de35b410fb165377550cdf9c4d3a80fbbcc961e111914e4d5c0eaf5729f.css integrity="sha256-fSct41tBD7FlN3VQzfnE06gPu8yWHhEZFOTVwOr1cp8=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/fontawesome/css/solid.min.55d8333481b07a08e07cf6f37319753a2b47e99f4c395394c5747b48b495aa9b.css integrity="sha256-VdgzNIGwegjgfPbzcxl1OitH6Z9MOVOUxXR7SLSVqps=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/fontawesome/css/regular.min.a7448d02590b43449364b6b5922ed9af5410abb4de4238412a830316dedb850b.css integrity="sha256-p0SNAlkLQ0STZLa1ki7Zr1QQq7TeQjhBKoMDFt7bhQs=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/fontawesome/css/brands.min.9ed75a5d670c953fe4df935937674b4646f92674367e9e66eb995bb04e821647.css integrity="sha256-ntdaXWcMlT/k35NZN2dLRkb5JnQ2fp5m65lbsE6CFkc=" crossorigin=anonymous type=text/css><link rel="shortcut icon" href=/favicon.ico type=image/x-icon><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=canonical href=https://computer-vision-talks.com/post/2012-11-06-maximizing-performance-grayscale-color-conversion-using-neon-and-cvparallel_for/><script type=text/javascript src=/js/anatole-header.min.f9132794301a01ff16550ed66763482bd848f62243d278f5e550229a158bfd32.js integrity="sha256-+RMnlDAaAf8WVQ7WZ2NIK9hI9iJD0nj15VAimhWL/TI=" crossorigin=anonymous></script>
<script type=text/javascript src=/js/anatole-theme-switcher.min.560a26330d27ff44a44e83b53cd07a95d4230a65930d31c5c76a8d481e5b35bf.js integrity="sha256-VgomMw0n/0SkToO1PNB6ldQjCmWTDTHFx2qNSB5bNb8=" crossorigin=anonymous></script><meta name=twitter:card content="summary"><meta name=twitter:title content="Maximizing performance of CV_BGRA2GRAY conversion using NEON and cv::parallel_for"><meta name=twitter:description content="I continue playing with powerful NEON engine in iPhone and iPad devices. Recently i bought iPhone 4S that replaced my HTC Mozart and i decided to check how to speed up BGRA to GRAY color conversion procedure using multithreading. Recently Itseez announced a minor release of OpenCV 2.4.3 with a lot of new major features:
 Added universal parallel_for implementation using various backends: TBB, OpenMP, GCD, Concurrency Improved OpenCV Manager, new Java samples framework, better camera support on Android, opencv2."><meta property="og:title" content="Maximizing performance of CV_BGRA2GRAY conversion using NEON and cv::parallel_for"><meta property="og:description" content="I continue playing with powerful NEON engine in iPhone and iPad devices. Recently i bought iPhone 4S that replaced my HTC Mozart and i decided to check how to speed up BGRA to GRAY color conversion procedure using multithreading. Recently Itseez announced a minor release of OpenCV 2.4.3 with a lot of new major features:
 Added universal parallel_for implementation using various backends: TBB, OpenMP, GCD, Concurrency Improved OpenCV Manager, new Java samples framework, better camera support on Android, opencv2."><meta property="og:type" content="article"><meta property="og:url" content="https://computer-vision-talks.com/post/2012-11-06-maximizing-performance-grayscale-color-conversion-using-neon-and-cvparallel_for/"><meta property="article:section" content="post"><meta property="article:published_time" content="2012-11-06T00:00:00+00:00"><meta property="article:modified_time" content="2012-11-06T00:00:00+00:00"><meta property="og:site_name" content="Computer Vision Talks"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","articleSection":"post","name":"Maximizing performance of CV_BGRA2GRAY conversion using NEON and cv::parallel_for","headline":"Maximizing performance of CV_BGRA2GRAY conversion using NEON and cv::parallel_for","alternativeHeadline":"","description":"
      
        I continue playing with powerful NEON engine in iPhone and iPad devices. Recently i bought iPhone 4S that replaced my HTC Mozart and i decided to check how to speed up BGRA to GRAY color conversion procedure using multithreading. Recently Itseez announced a minor release of OpenCV 2.4.3 with a lot of new major features:\n Added universal parallel_for implementation using various backends: TBB, OpenMP, GCD, Concurrency Improved OpenCV Manager, new Java samples framework, better camera support on Android, opencv2.


      


    ","inLanguage":"en-us","isFamilyFriendly":"true","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/computer-vision-talks.com\/post\/2012-11-06-maximizing-performance-grayscale-color-conversion-using-neon-and-cvparallel_for\/"},"author":{"@type":"Person","name":"Eugene Khvedchenya"},"creator":{"@type":"Person","name":"Eugene Khvedchenya"},"accountablePerson":{"@type":"Person","name":"Eugene Khvedchenya"},"copyrightHolder":{"@type":"Person","name":"Eugene Khvedchenya"},"copyrightYear":"2012","dateCreated":"2012-11-06T00:00:00.00Z","datePublished":"2012-11-06T00:00:00.00Z","dateModified":"2012-11-06T00:00:00.00Z","publisher":{"@type":"Organization","name":"Eugene Khvedchenya","url":"https://computer-vision-talks.com/","logo":{"@type":"ImageObject","url":"https:\/\/computer-vision-talks.com\/favicon-32x32.png","width":"32","height":"32"}},"image":[],"url":"https:\/\/computer-vision-talks.com\/post\/2012-11-06-maximizing-performance-grayscale-color-conversion-using-neon-and-cvparallel_for\/","wordCount":"913","genre":[],"keywords":["opencv","xcode","neon","iphone"]}</script></head><body class="body theme--light"><div class=wrapper><aside class=wrapper__sidebar><div class="sidebar
animated fadeInDown"><div class=sidebar__content><div class=sidebar__introduction><img class=sidebar__introduction-profileimage src=/images/4ECfkGJr_400x400.jpg alt="profile picture"><div class=sidebar__introduction-title><a href=/>Computer Vision Talks</a></div><div class=sidebar__introduction-description><p>A personal blog about Computer Vision, AI, Kaggle, Open-Source and research. You will never read this in books.</p></div></div><ul class=sidebar__list><li class=sidebar__list-item><a href=https://www.linkedin.com/in/cvtalks/ target=_blank rel=noopener aria-label=Linkedin title=Linkedin><i class="fab fa-linkedin fa-2x" aria-hidden=true></i></a></li><li class=sidebar__list-item><a href=https://twitter.com/cvtalks target=_blank rel=noopener aria-label=Twitter title=Twitter><i class="fab fa-twitter fa-2x" aria-hidden=true></i></a></li><li class=sidebar__list-item><a href=https://github.com/BloodAxe target=_blank rel=noopener aria-label=GitHub title=GitHub><i class="fab fa-github fa-2x" aria-hidden=true></i></a></li><li class=sidebar__list-item><a href=mailto:ekhvedchenya@computer-vision-talks.com target=_blank rel=noopener aria-label=E-Mail title=E-Mail><i class="fas fa-envelope fa-2x" aria-hidden=true></i></a></li></ul></div><footer class="footer footer__sidebar"><ul class=footer__list><li class=footer__item>&copy;
Eugene Khvedchenya
2022</li></ul></footer><script type=text/javascript src=/js/medium-zoom.min.9c062c557275acbaba71f0c7cd4024da3e3cc825d248bc4b2130811b0965330b.js integrity="sha256-nAYsVXJ1rLq6cfDHzUAk2j48yCXSSLxLITCBGwllMws=" crossorigin=anonymous></script>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-10687369-5","auto"),ga("send","pageview"))</script><script async src=https://www.google-analytics.com/analytics.js></script></div></aside><main class=wrapper__main><header class=header><div class="animated fadeInDown"><a role=button class=navbar-burger data-target=navMenu aria-label=menu aria-expanded=false><span aria-hidden=true class=navbar-burger__line></span>
<span aria-hidden=true class=navbar-burger__line></span>
<span aria-hidden=true class=navbar-burger__line></span></a><nav class=nav><ul class=nav__list id=navMenu><li class=nav__list-item><a href=/ title>Home</a></li><li class=nav__list-item><a href=/post/ title>Posts</a></li><li class=nav__list-item><a href=/open-source title>Open-Source</a></li><li class=nav__list-item><a href=/challenges title>Wins</a></li><li class=nav__list-item><a href=/publications title>Publications</a></li></ul><ul class="nav__list nav__list--end"><li class=nav__list-item><div class=themeswitch><a title="Switch Theme"><i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></li></ul></nav></div></header><div class="post
animated fadeInDown"><div class=post__content><h1>Maximizing Performance of CV_BGRA2GRAY Conversion Using NEON and Cv::parallel_for</h1><ul class=post__meta><li class=post__meta-item><em class="fas fa-calendar-day post__meta-icon"></em>
<span class=post__meta-text>Tue, Nov 6, 2012</span></li><li class=post__meta-item><em class="fas fa-stopwatch post__meta-icon"></em>
<span class=post__meta-text>5-minute read</span></li></ul><p>I continue playing with powerful NEON engine in iPhone and iPad devices. Recently i bought iPhone 4S that replaced my HTC Mozart and i decided to check how to speed up BGRA to GRAY color conversion procedure using multithreading.</p><p>Recently Itseez announced a minor release of OpenCV 2.4.3 with a lot of new major features:</p><ul><li>Added universal parallel_for implementation using various backends: TBB, OpenMP, GCD, Concurrency</li><li>Improved OpenCV Manager, new Java samples framework, better camera support on Android,</li><li>opencv2.framework is now iOS6- and iPhone5- (armv7s) compatible.</li></ul><p>The rest of changes can be seen here: <a href=http://code.opencv.org/projects/opencv/wiki/ChangeLog>http://code.opencv.org/projects/opencv/wiki/ChangeLog</a>. In the past i wrote a NEON-optimized grayscale conversion algorithm (<a href=http://computer-vision-talks.com/2011/02/a-very-fast-bgra-to-grayscale-conversion-on-iphone/>http://computer-vision-talks.com/2011/02/a-very-fast-bgra-to-grayscale-conversion-on-iphone/</a>) which showed a pretty nice speed-up (About 2x times faster than cv::cvtColor(input, output, CV_BGRA2GRAY)). In this post we will use these results as a baseline and try to write something faster. To be fair we start from defining a set of rules for all implementations:</p><ul><li>We will process square images of size (8, 10, 12, 14, 16, 18, &mldr;., 1596, 1598, 1600) pixels. Processing small and big images will reveal hidden bottlenecks of each implementation.</li><li>Each image will be processed 1000 to avoid measurement fluctuations.</li><li>The destination image will be preallocated prior the test to exclude memory allocations influence.</li><li>We use mach_absolute_time() to measure processing time. As far as i know it&rsquo;s the most precise measuring method.</li></ul><p>Our main test method looks like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>typedef</span> <span class=kt>void</span> <span class=nf>ConversionFunctionPrototype</span><span class=p>(</span><span class=k>const</span> <span class=n>cv</span><span class=o>::</span><span class=n>Mat</span><span class=o>&amp;</span> <span class=n>input</span><span class=p>,</span> <span class=n>cv</span><span class=o>::</span><span class=n>Mat</span><span class=o>&amp;</span> <span class=n>output</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>testConversion</span><span class=p>(</span><span class=k>const</span> <span class=n>cv</span><span class=o>::</span><span class=n>Mat</span><span class=o>&amp;</span> <span class=n>input</span><span class=p>,</span> <span class=kt>int</span> <span class=n>numRuns</span><span class=p>,</span> <span class=kt>int</span><span class=o>&amp;</span> <span class=n>avgTimeInMicroseconds</span><span class=p>,</span> <span class=n>ConversionFunctionPrototype</span> <span class=n>conversionFn</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>assert</span><span class=p>(</span><span class=n>input</span><span class=p>.</span><span class=n>type</span><span class=p>()</span> <span class=o>==</span> <span class=n>CV_8UC4</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>assert</span><span class=p>(</span><span class=n>input</span><span class=p>.</span><span class=n>empty</span><span class=p>()</span> <span class=o>==</span> <span class=nb>false</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>cv</span><span class=o>::</span><span class=n>Mat</span> <span class=n>output</span><span class=p>(</span><span class=n>input</span><span class=p>.</span><span class=n>size</span><span class=p>(),</span> <span class=n>CV_8UC1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>uint64_t</span> <span class=n>conversionStart</span><span class=p>,</span> <span class=n>conversionFinish</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint64_t</span> <span class=n>totalTime</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>numRuns</span> <span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>conversionStart</span> <span class=o>=</span> <span class=n>mach_absolute_time</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=n>conversionFn</span><span class=p>(</span><span class=n>input</span><span class=p>,</span> <span class=n>output</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>conversionFinish</span> <span class=o>=</span> <span class=n>mach_absolute_time</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>totalTime</span> <span class=o>+=</span> <span class=p>(</span><span class=n>conversionFinish</span> <span class=o>-</span> <span class=n>conversionStart</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>mach_timebase_info_data_t</span> <span class=n>timebase</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>mach_timebase_info</span><span class=p>(</span><span class=o>&amp;</span><span class=n>timebase</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>avgTimeInMicroseconds</span> <span class=o>=</span> <span class=p>(</span><span class=kt>int</span><span class=p>)</span> <span class=p>((</span><span class=kt>double</span><span class=p>)</span><span class=n>totalTime</span> <span class=o>*</span> <span class=p>(</span><span class=kt>double</span><span class=p>)</span><span class=n>timebase</span><span class=p>.</span><span class=n>numer</span> <span class=o>/</span> <span class=p>((</span><span class=kt>double</span><span class=p>)</span><span class=n>timebase</span><span class=p>.</span><span class=n>denom</span> <span class=o>*</span> <span class=p>(</span><span class=kt>double</span><span class=p>)</span><span class=n>numRuns</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The testConversion function computes the average BGRA2GRAY conversion time of the input image by doing color conversion N times (specified by numRuns argument).</p><h2 id=opencv-implementation>OpenCV implementation</h2><p>The reference color conversion function from OpenCV:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>convert_opencv</span><span class=p>(</span><span class=k>const</span> <span class=n>cv</span><span class=o>::</span><span class=n>Mat</span><span class=o>&amp;</span> <span class=n>input</span><span class=p>,</span> <span class=n>cv</span><span class=o>::</span><span class=n>Mat</span><span class=o>&amp;</span> <span class=n>output</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>cv</span><span class=o>::</span><span class=n>cvtColor</span><span class=p>(</span><span class=n>input</span><span class=p>,</span> <span class=n>output</span><span class=p>,</span> <span class=n>CV_BGRA2GRAY</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=arm-neon-using-assembler>ARM NEON using assembler</h2><p>The old assembler version of NEON-accelerated color conversion from my old post:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>convert_neon_asm_8px</span><span class=p>(</span><span class=k>const</span> <span class=n>cv</span><span class=o>::</span><span class=n>Mat</span><span class=o>&amp;</span> <span class=n>input</span><span class=p>,</span> <span class=n>cv</span><span class=o>::</span><span class=n>Mat</span><span class=o>&amp;</span> <span class=n>output</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint8_t</span> <span class=n>__restrict</span> <span class=o>*</span> <span class=n>dest</span> <span class=o>=</span> <span class=n>output</span><span class=p>.</span><span class=n>data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint8_t</span> <span class=n>__restrict</span> <span class=o>*</span> <span class=n>src</span>  <span class=o>=</span> <span class=n>input</span><span class=p>.</span><span class=n>data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>numPixels</span>             <span class=o>=</span> <span class=n>input</span><span class=p>.</span><span class=n>total</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>__asm__</span> <span class=k>volatile</span><span class=p>(</span><span class=s>&#34;lsr          %2, %2, #3      </span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>                     <span class=s>&#34;# build the three constants: </span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>                     <span class=s>&#34;mov         r4, #28          </span><span class=se>\n</span><span class=s>&#34;</span> <span class=c1>// Blue channel multiplier
</span></span></span><span class=line><span class=cl><span class=c1></span>                     <span class=s>&#34;mov         r5, #151         </span><span class=se>\n</span><span class=s>&#34;</span> <span class=c1>// Green channel multiplier
</span></span></span><span class=line><span class=cl><span class=c1></span>                     <span class=s>&#34;mov         r6, #77          </span><span class=se>\n</span><span class=s>&#34;</span> <span class=c1>// Red channel multiplier
</span></span></span><span class=line><span class=cl><span class=c1></span>                     <span class=s>&#34;vdup.8      d4, r4           </span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>                     <span class=s>&#34;vdup.8      d5, r5           </span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>                     <span class=s>&#34;vdup.8      d6, r6           </span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>                     <span class=s>&#34;0:                           </span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>                     <span class=s>&#34;# load 8 pixels:             </span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>                     <span class=s>&#34;vld4.8      {d0-d3}, [%1]!   </span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>                     <span class=s>&#34;# do the weight average:     </span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>                     <span class=s>&#34;vmull.u8    q7, d0, d4       </span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>                     <span class=s>&#34;vmlal.u8    q7, d1, d5       </span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>                     <span class=s>&#34;vmlal.u8    q7, d2, d6       </span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>                     <span class=s>&#34;# shift and store:           </span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>                     <span class=s>&#34;vshrn.u16   d7, q7, #8       </span><span class=se>\n</span><span class=s>&#34;</span> <span class=c1>// Divide q3 by 256 and store in the d7
</span></span></span><span class=line><span class=cl><span class=c1></span>                     <span class=s>&#34;vst1.8      {d7}, [%0]!      </span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>                     <span class=s>&#34;subs        %2, %2, #1       </span><span class=se>\n</span><span class=s>&#34;</span> <span class=c1>// Decrement iteration count
</span></span></span><span class=line><span class=cl><span class=c1></span>                     <span class=s>&#34;bne         0b            </span><span class=se>\n</span><span class=s>&#34;</span> <span class=c1>// Repeat until iteration count is not zero
</span></span></span><span class=line><span class=cl><span class=c1></span>                     <span class=o>:</span>
</span></span><span class=line><span class=cl>                     <span class=o>:</span> <span class=s>&#34;r&#34;</span><span class=p>(</span><span class=n>dest</span><span class=p>),</span> <span class=s>&#34;r&#34;</span><span class=p>(</span><span class=n>src</span><span class=p>),</span> <span class=s>&#34;r&#34;</span><span class=p>(</span><span class=n>numPixels</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                     <span class=o>:</span> <span class=s>&#34;r4&#34;</span><span class=p>,</span> <span class=s>&#34;r5&#34;</span><span class=p>,</span> <span class=s>&#34;r6&#34;</span>
</span></span><span class=line><span class=cl>                     <span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=arm-neon-using-intrinsics>ARM NEON using intrinsics</h2><p>You know you can write the same code using arm intrinsics? Here it is:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>convert_neon8px_int</span><span class=p>(</span><span class=k>const</span> <span class=n>cv</span><span class=o>::</span><span class=n>Mat</span><span class=o>&amp;</span> <span class=n>input</span><span class=p>,</span> <span class=n>cv</span><span class=o>::</span><span class=n>Mat</span><span class=o>&amp;</span> <span class=n>output</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint8_t</span> <span class=n>__restrict</span> <span class=o>*</span> <span class=n>dest</span> <span class=o>=</span> <span class=n>output</span><span class=p>.</span><span class=n>data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint8_t</span> <span class=n>__restrict</span> <span class=o>*</span> <span class=n>src</span>  <span class=o>=</span> <span class=n>input</span><span class=p>.</span><span class=n>data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>numPixels</span>             <span class=o>=</span> <span class=n>input</span><span class=p>.</span><span class=n>total</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>uint8x8_t</span> <span class=n>rfac</span> <span class=o>=</span> <span class=n>vdup_n_u8</span> <span class=p>(</span><span class=mi>77</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>uint8x8_t</span> <span class=n>gfac</span> <span class=o>=</span> <span class=n>vdup_n_u8</span> <span class=p>(</span><span class=mi>151</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>uint8x8_t</span> <span class=n>bfac</span> <span class=o>=</span> <span class=n>vdup_n_u8</span> <span class=p>(</span><span class=mi>28</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>register</span> <span class=kt>int</span> <span class=n>n</span> <span class=o>=</span> <span class=n>numPixels</span> <span class=o>/</span> <span class=mi>8</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>uint16x8_t</span>  <span class=n>temp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>uint8x8_t</span> <span class=n>result</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>uint8x8x4_t</span> <span class=n>rgb</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=k>register</span> <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>n</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>,</span> <span class=n>src</span> <span class=o>+=</span> <span class=mi>8</span><span class=o>*</span><span class=mi>4</span><span class=p>,</span> <span class=n>dest</span> <span class=o>+=</span> <span class=mi>8</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>rgb</span>  <span class=o>=</span> <span class=n>vld4_u8</span> <span class=p>(</span><span class=n>src</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>temp</span> <span class=o>=</span> <span class=n>vmull_u8</span> <span class=p>(</span><span class=n>rgb</span><span class=p>.</span><span class=n>val</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span>      <span class=n>rfac</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>temp</span> <span class=o>=</span> <span class=n>vmlal_u8</span> <span class=p>(</span><span class=n>temp</span><span class=p>,</span><span class=n>rgb</span><span class=p>.</span><span class=n>val</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=n>gfac</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>temp</span> <span class=o>=</span> <span class=n>vmlal_u8</span> <span class=p>(</span><span class=n>temp</span><span class=p>,</span><span class=n>rgb</span><span class=p>.</span><span class=n>val</span><span class=p>[</span><span class=mi>2</span><span class=p>],</span> <span class=n>bfac</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>result</span> <span class=o>=</span> <span class=n>vshrn_n_u16</span> <span class=p>(</span><span class=n>temp</span><span class=p>,</span> <span class=mi>8</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>vst1_u8</span> <span class=p>(</span><span class=n>dest</span><span class=p>,</span> <span class=n>result</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=parallel-neon-version>Parallel NEON version</h2><p>Both <strong>convert_neon_asm_8px</strong> and <strong>convert_neon8px_int</strong> functions process 8 pixels at once. This color conversion function is a great candidate for multithreading optimization. Since iPhone 4S and iPad 2 have two Cortex A8 CPU we can run our color conversion in two threads. For this purpose we want to use Grand Central Dispatch mechanism from iOS. It provides easy mechanism to execute tasks in multithreaded environment. OpenCV developers offers new nice feature to perform parallel calculation - <strong>cv::parallel_for</strong>. This function provides abstraction layer between multithreading backend and user code. To use <strong>cv::parallel_for</strong> you have to implement a cv::ParallelLoopBody functor:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// a base body class
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>CV_EXPORTS</span> <span class=n>ParallelLoopBody</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=o>~</span><span class=n>ParallelLoopBody</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=nf>operator</span><span class=p>()</span> <span class=p>(</span><span class=k>const</span> <span class=n>Range</span><span class=o>&amp;</span> <span class=n>range</span><span class=p>)</span> <span class=k>const</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>CV_EXPORTS</span> <span class=kt>void</span> <span class=nf>parallel_for_</span><span class=p>(</span><span class=k>const</span> <span class=n>Range</span><span class=o>&amp;</span> <span class=n>range</span><span class=p>,</span> <span class=k>const</span> <span class=n>ParallelLoopBody</span><span class=o>&amp;</span> <span class=n>body</span><span class=p>,</span> <span class=kt>double</span> <span class=n>nstripes</span><span class=o>=-</span><span class=mf>1.</span><span class=p>);</span>
</span></span></code></pre></div><p>Our color conversion function simply wraps the code from the ARM NEON version with slight modifications. When counting the number of pixels to process we take into account the range argument passed to the function body.</p><pre tabindex=0><code>struct convert_ParallelLoopBody : public cv::ParallelLoopBody
{
    convert_ParallelLoopBody(const cv::Mat&amp; input, cv::Mat&amp; output)
    : _in(input)
    , _out(output)
    {
    }

    void operator() (const cv::Range&amp; range) const
    {
        uint8_t __restrict * dest = _out.data + range.start;
        uint8_t __restrict * src  = _in.data  + range.start * 4;

        int numPixels             = range.size();

        uint8x8_t rfac = vdup_n_u8 (77);
        uint8x8_t gfac = vdup_n_u8 (151);
        uint8x8_t bfac = vdup_n_u8 (28);

        register int n = numPixels / 8;
        uint16x8_t  temp;
        uint8x8_t result;
        uint8x8x4_t rgb;

        for (register int i = 0; i &lt; n; i++, src += 8*4, dest += 8)
        {
            rgb  = vld4_u8 (src);

            temp = vmull_u8 (rgb.val[0],      rfac);
            temp = vmlal_u8 (temp,rgb.val[1
        }
    }
}
</code></pre></div><div class=post__footer><span><a class=tag href=/tags/opencv/>opencv</a><a class=tag href=/tags/xcode/>xcode</a><a class=tag href=/tags/neon/>neon</a><a class=tag href=/tags/iphone/>iphone</a></span></div><div id=comment><h2>comments</h2><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//cvtalks.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></div></main></div><footer class="footer footer__base"><ul class=footer__list><li class=footer__item>&copy;
Eugene Khvedchenya
2022</li></ul></footer><script type=text/javascript src=/js/medium-zoom.min.9c062c557275acbaba71f0c7cd4024da3e3cc825d248bc4b2130811b0965330b.js integrity="sha256-nAYsVXJ1rLq6cfDHzUAk2j48yCXSSLxLITCBGwllMws=" crossorigin=anonymous></script>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-10687369-5","auto"),ga("send","pageview"))</script><script async src=https://www.google-analytics.com/analytics.js></script></body></html>