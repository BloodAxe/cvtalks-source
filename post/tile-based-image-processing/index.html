<!doctype html><html dir=ltr lang=en data-theme class=html><head><title>Eugene Khvedchenya
|
Tile-based image processing</title><meta charset=utf-8><meta name=generator content="Hugo 0.98.0"><meta name=viewport content="width=device-width,initial-scale=1,viewport-fit=cover"><meta name=author content="Eugene Khvedchenya"><meta name=description content="A personal blog about Computer Vision, AI, Kaggle, Open-Source and research. You will never read this in books."><link rel=stylesheet href=/scss/main.min.b2e0cb07595e3519ab1193bb421914e06c0e26b0cc561fef23b3c6131d4d2ffa.css integrity="sha256-suDLB1leNRmrEZO7QhkU4GwOJrDMVh/vI7PGEx1NL/o=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/css/markupHighlight.min.31b0a1f317f55c529a460897848c97436bb138b19c399b37de70d463a8bf6ed5.css integrity="sha256-MbCh8xf1XFKaRgiXhIyXQ2uxOLGcOZs33nDUY6i/btU=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/fontawesome/css/fontawesome.min.7d272de35b410fb165377550cdf9c4d3a80fbbcc961e111914e4d5c0eaf5729f.css integrity="sha256-fSct41tBD7FlN3VQzfnE06gPu8yWHhEZFOTVwOr1cp8=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/fontawesome/css/solid.min.55d8333481b07a08e07cf6f37319753a2b47e99f4c395394c5747b48b495aa9b.css integrity="sha256-VdgzNIGwegjgfPbzcxl1OitH6Z9MOVOUxXR7SLSVqps=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/fontawesome/css/regular.min.a7448d02590b43449364b6b5922ed9af5410abb4de4238412a830316dedb850b.css integrity="sha256-p0SNAlkLQ0STZLa1ki7Zr1QQq7TeQjhBKoMDFt7bhQs=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/fontawesome/css/brands.min.9ed75a5d670c953fe4df935937674b4646f92674367e9e66eb995bb04e821647.css integrity="sha256-ntdaXWcMlT/k35NZN2dLRkb5JnQ2fp5m65lbsE6CFkc=" crossorigin=anonymous type=text/css><link rel="shortcut icon" href=/favicon.ico type=image/x-icon><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=canonical href=https://computer-vision-talks.com/post/tile-based-image-processing/><script type=text/javascript src=/js/anatole-header.min.f9132794301a01ff16550ed66763482bd848f62243d278f5e550229a158bfd32.js integrity="sha256-+RMnlDAaAf8WVQ7WZ2NIK9hI9iJD0nj15VAimhWL/TI=" crossorigin=anonymous></script>
<script type=text/javascript src=/js/anatole-theme-switcher.min.560a26330d27ff44a44e83b53cd07a95d4230a65930d31c5c76a8d481e5b35bf.js integrity="sha256-VgomMw0n/0SkToO1PNB6ldQjCmWTDTHFx2qNSB5bNb8=" crossorigin=anonymous></script><meta name=twitter:card content="summary"><meta name=twitter:title content="Tile-based image processing"><meta name=twitter:description content="How would you design an algorithm to process 40Mpx image? 100Mpx? What about gigapixel-sized panorams? Obviously, it should differs from those that are intended for 640x480 images. Here I want to present you implementation of the very simple but powerful approach called &ldquo;Tile-based image processing&rdquo;. I will show you how to make this using OpenCV.
First, let&rsquo;s define a few restrictions in order to simplify our implementation. In this tutorial I will consider a &lsquo;pass-through&rsquo; pipeline - when we apply some function to input image and give an output image of the same size as an output."><meta property="og:title" content="Tile-based image processing"><meta property="og:description" content="How would you design an algorithm to process 40Mpx image? 100Mpx? What about gigapixel-sized panorams? Obviously, it should differs from those that are intended for 640x480 images. Here I want to present you implementation of the very simple but powerful approach called &ldquo;Tile-based image processing&rdquo;. I will show you how to make this using OpenCV.
First, let&rsquo;s define a few restrictions in order to simplify our implementation. In this tutorial I will consider a &lsquo;pass-through&rsquo; pipeline - when we apply some function to input image and give an output image of the same size as an output."><meta property="og:type" content="article"><meta property="og:url" content="https://computer-vision-talks.com/post/tile-based-image-processing/"><meta property="article:section" content="post"><meta property="article:published_time" content="2014-12-04T00:00:00+00:00"><meta property="article:modified_time" content="2014-12-04T00:00:00+00:00"><meta property="og:site_name" content="Computer Vision Talks"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","articleSection":"post","name":"Tile-based image processing","headline":"Tile-based image processing","alternativeHeadline":"","description":"
      
        How would you design an algorithm to process 40Mpx image? 100Mpx? What about gigapixel-sized panorams? Obviously, it should differs from those that are intended for 640x480 images. Here I want to present you implementation of the very simple but powerful approach called \u0026ldquo;Tile-based image processing\u0026rdquo;. I will show you how to make this using OpenCV.\nFirst, let\u0026rsquo;s define a few restrictions in order to simplify our implementation. In this tutorial I will consider a \u0026lsquo;pass-through\u0026rsquo; pipeline - when we apply some function to input image and give an output image of the same size as an output.


      


    ","inLanguage":"en-us","isFamilyFriendly":"true","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/computer-vision-talks.com\/post\/tile-based-image-processing\/"},"author":{"@type":"Person","name":"Eugene Khvedchenya"},"creator":{"@type":"Person","name":"Eugene Khvedchenya"},"accountablePerson":{"@type":"Person","name":"Eugene Khvedchenya"},"copyrightHolder":{"@type":"Person","name":"Eugene Khvedchenya"},"copyrightYear":"2014","dateCreated":"2014-12-04T00:00:00.00Z","datePublished":"2014-12-04T00:00:00.00Z","dateModified":"2014-12-04T00:00:00.00Z","publisher":{"@type":"Organization","name":"Eugene Khvedchenya","url":"https://computer-vision-talks.com/","logo":{"@type":"ImageObject","url":"https:\/\/computer-vision-talks.com\/favicon-32x32.png","width":"32","height":"32"}},"image":[],"url":"https:\/\/computer-vision-talks.com\/post\/tile-based-image-processing\/","wordCount":"1355","genre":[],"keywords":["opencv","tutorials","algorithms"]}</script></head><body class="body theme--light"><div class=wrapper><aside class=wrapper__sidebar><div class="sidebar
animated fadeInDown"><div class=sidebar__content><div class=sidebar__introduction><img class=sidebar__introduction-profileimage src=/images/4ECfkGJr_400x400.jpg alt="profile picture"><div class=sidebar__introduction-title><a href=/>Computer Vision Talks</a></div><div class=sidebar__introduction-description><p>A personal blog about Computer Vision, AI, Kaggle, Open-Source and research. You will never read this in books.</p></div></div><ul class=sidebar__list><li class=sidebar__list-item><a href=https://www.linkedin.com/in/cvtalks/ target=_blank rel=noopener aria-label=Linkedin title=Linkedin><i class="fab fa-linkedin fa-2x" aria-hidden=true></i></a></li><li class=sidebar__list-item><a href=https://twitter.com/cvtalks target=_blank rel=noopener aria-label=Twitter title=Twitter><i class="fab fa-twitter fa-2x" aria-hidden=true></i></a></li><li class=sidebar__list-item><a href=https://github.com/BloodAxe target=_blank rel=noopener aria-label=GitHub title=GitHub><i class="fab fa-github fa-2x" aria-hidden=true></i></a></li><li class=sidebar__list-item><a href=mailto:ekhvedchenya@computer-vision-talks.com target=_blank rel=noopener aria-label=E-Mail title=E-Mail><i class="fas fa-envelope fa-2x" aria-hidden=true></i></a></li></ul></div><footer class="footer footer__sidebar"><ul class=footer__list><li class=footer__item>&copy;
Eugene Khvedchenya
2022</li></ul></footer><script type=text/javascript src=/js/medium-zoom.min.9c062c557275acbaba71f0c7cd4024da3e3cc825d248bc4b2130811b0965330b.js integrity="sha256-nAYsVXJ1rLq6cfDHzUAk2j48yCXSSLxLITCBGwllMws=" crossorigin=anonymous></script>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-10687369-5","auto"),ga("send","pageview"))</script><script async src=https://www.google-analytics.com/analytics.js></script></div></aside><main class=wrapper__main><header class=header><div class="animated fadeInDown"><a role=button class=navbar-burger data-target=navMenu aria-label=menu aria-expanded=false><span aria-hidden=true class=navbar-burger__line></span>
<span aria-hidden=true class=navbar-burger__line></span>
<span aria-hidden=true class=navbar-burger__line></span></a><nav class=nav><ul class=nav__list id=navMenu><li class=nav__list-item><a href=/ title>Home</a></li><li class=nav__list-item><a href=/post/ title>Posts</a></li><li class=nav__list-item><a href=/open-source title>Open-Source</a></li><li class=nav__list-item><a href=/challenges title>Wins</a></li><li class=nav__list-item><a href=/publications title>Publications</a></li></ul><ul class="nav__list nav__list--end"><li class=nav__list-item><div class=themeswitch><a title="Switch Theme"><i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></li></ul></nav></div></header><div class="post
animated fadeInDown"><div class=post__content><h1>Tile-Based Image Processing</h1><ul class=post__meta><li class=post__meta-item><em class="fas fa-calendar-day post__meta-icon"></em>
<span class=post__meta-text>Thu, Dec 4, 2014</span></li><li class=post__meta-item><em class="fas fa-stopwatch post__meta-icon"></em>
<span class=post__meta-text>7-minute read</span></li></ul><p>How would you design an algorithm to process 40Mpx image? 100Mpx? What about gigapixel-sized panorams? Obviously, it should differs from those that are intended for 640x480 images. Here I want to present you implementation of the very simple but powerful approach called &ldquo;Tile-based image processing&rdquo;. I will show you how to make this using OpenCV.</p><p><img src=tiles.png alt="Tile based image processing"></p><p>First, let&rsquo;s define a few restrictions in order to simplify our implementation. In this tutorial I will consider a &lsquo;pass-through&rsquo; pipeline - when we apply some function to input image and give an output image of the same size as an output.</p><p>It is possible to extend this approach to work with many input images, but for the sake of simplicity I&rsquo;ll omit this for now.</p><p>Consider a following algorithm:</p><ol><li>Take a source image for RGB color space.</li><li>Convert in to grayscale color space (unsigned byte).</li><li>Compute Sobel derivatives (signed short).</li><li>Take a Dx, Dy for each pixel and compute it&rsquo;s magnitude and orientation.</li><li>Leave only those, which magnitude is larger than threshold.</li></ol><p>Using OpenCV it could look like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>cv</span><span class=o>::</span><span class=n>Mat</span> <span class=n>source</span> <span class=o>=</span> <span class=n>cv</span><span class=o>::</span><span class=n>imread</span><span class=p>(</span><span class=s>&#34;input.jpg&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>cv</span><span class=o>::</span><span class=n>Mat</span> <span class=n>grayscale</span><span class=p>,</span> <span class=n>dx</span><span class=p>,</span> <span class=n>dy</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>cv</span><span class=o>::</span><span class=n>cvtColor</span><span class=p>(</span><span class=n>source</span><span class=p>,</span> <span class=n>grayscale</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>cv</span><span class=o>::</span><span class=n>Sobel</span><span class=p>(</span><span class=n>grayscale</span><span class=p>,</span> <span class=n>dx</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>cv</span><span class=o>::</span><span class=n>Sobel</span><span class=p>(</span><span class=n>grayscale</span><span class=p>,</span> <span class=n>dy</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span></code></pre></div><h2 id=problems-with-straighforward-implementation>Problems with straighforward implementation</h2><p>This routine require <code>N + 2 * N * sizeof(signed short)</code> bytes of additional memory for straightforward implementation, where N is number of pixels in source image. Large number of intermediate buffers can cause memory issues for memory restricted devices (mobile phones, embedded systems).</p><blockquote><p>On iOS, in particular, your app might get terminated by iOS watchdog for high peak RAM usage, despite the fact you use this memory only for a temp buffers.</p></blockquote><p>Second issue with large amount of buffers is cache-misses. Large buffers are likely to sit near each other, therefore cache performance will be low and algorithm performance will suffer.</p><p>To adress those two issues, I suggest to divide input image into &ldquo;Tiles&rdquo; - regions of the original image of equal size, let&rsquo;s say 64x64. The processing function remains the same, but we reuse all temporary buffers and process only 64x64 pixels at one time.</p><p><img src=algorithm.png alt="Tile based image processing"></p><p>Let&rsquo;s say we&rsquo;re processing <code>1280x720</code> frame, using regular approach, the total amount of
additional memory is <strong>4.6 megabytes</strong> (<code>4608000</code> bytes). With tile-based approach, we need only <strong>20 kilobytes</strong> (<code>20480</code> bytes). 20K are likely to fit entirely in L2 cache and therefore give a significant performance boost.</p><h2 id=tile-based-implementation>Tile-based implementation</h2><p>To implement tile-based implementation, we iterate over the image, copy tiles from source image to our local source tile, process it and write to corresponding area in the
destination image.</p><p>A pseudo-code for this routine is follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=kt>int</span> <span class=n>TileSize</span><span class=p>,</span> <span class=k>typename</span> <span class=n>Algorithm</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>process</span><span class=p>(</span><span class=k>const</span> <span class=n>cv</span><span class=o>::</span><span class=n>Mat</span><span class=o>&amp;</span> <span class=n>sourceImage</span><span class=p>,</span> <span class=n>cv</span><span class=o>::</span><span class=n>Mat</span><span class=o>&amp;</span> <span class=n>resultImage</span><span class=p>,</span> <span class=n>Algorithm</span> <span class=n>algorithm</span><span class=p>)</span> <span class=k>const</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>assert</span><span class=p>(</span><span class=o>!</span><span class=n>resultImage</span><span class=p>.</span><span class=n>empty</span><span class=p>());</span>
</span></span><span class=line><span class=cl>    <span class=n>assert</span><span class=p>(</span><span class=n>sourceImage</span><span class=p>.</span><span class=n>rows</span> <span class=o>==</span> <span class=n>resultImage</span><span class=p>.</span><span class=n>rows</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>assert</span><span class=p>(</span><span class=n>sourceImage</span><span class=p>.</span><span class=n>cols</span> <span class=o>==</span> <span class=n>resultImage</span><span class=p>.</span><span class=n>cols</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=kt>int</span> <span class=n>rows</span> <span class=o>=</span> <span class=p>(</span><span class=n>sourceImage</span><span class=p>.</span><span class=n>rows</span> <span class=o>/</span> <span class=n>TileSize</span><span class=p>)</span> <span class=o>+</span> <span class=p>(</span><span class=n>sourceImage</span><span class=p>.</span><span class=n>rows</span> <span class=o>%</span> <span class=n>TileSize</span> <span class=o>?</span> <span class=mi>1</span> <span class=o>:</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=kt>int</span> <span class=n>cols</span> <span class=o>=</span> <span class=p>(</span><span class=n>sourceImage</span><span class=p>.</span><span class=n>cols</span> <span class=o>/</span> <span class=n>TileSize</span><span class=p>)</span> <span class=o>+</span> <span class=p>(</span><span class=n>sourceImage</span><span class=p>.</span><span class=n>cols</span> <span class=o>%</span> <span class=n>TileSize</span> <span class=o>?</span> <span class=mi>1</span> <span class=o>:</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>cv</span><span class=o>::</span><span class=n>Mat</span> <span class=n>tileInput</span><span class=p>,</span> <span class=n>tileOutput</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>rowTile</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>rowTile</span> <span class=o>&lt;</span> <span class=n>rows</span><span class=p>;</span> <span class=n>rowTile</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>colTile</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>colTile</span> <span class=o>&lt;</span> <span class=n>cols</span><span class=p>;</span> <span class=n>colTile</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>copyTileFromSource</span><span class=p>(</span><span class=n>sourceImage</span><span class=p>,</span> <span class=n>tileInput</span><span class=p>,</span> <span class=n>rowTile</span><span class=p>,</span> <span class=n>colTile</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>algorithm</span><span class=p>(</span><span class=n>tileInput</span><span class=p>,</span> <span class=n>tileOutput</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>copyTileToResultImage</span><span class=p>(</span><span class=n>tileOutput</span><span class=p>,</span> <span class=n>resultImage</span><span class=p>,</span> <span class=n>rowTile</span><span class=p>,</span> <span class=n>colTile</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>I hope it&rsquo;s clear to understand what is happening in code above. The <code>Algorithm</code> here represents some algorithm that we want to run on our tiles. There are two functions <code>copyTileFromSource</code> and <code>copyTileToResultImage</code> that will be covered a bit later.</p><h2 id=dealing-with-out-of-tile-reads>Dealing with out-of-tile reads</h2><p>You may ask yourself - what should we do with border pixels? Sobel operator use neighbor pixels around each pixel. When we construct a tile shouldn&rsquo;t we take this into account? Sure we are. So that&rsquo;s why there is a padding parameter that controls amount of additional pixels that are added to top, left, bottom and right of the tile in order to make functions that require additional pixels work correct.</p><p><img src=tile_with_paddings.png alt="Tile with paddings"></p><p>Padding makes tile overlap each other, but we pay this price for good cache locality.</p><p>I will use a slightly modified version of code from above:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>struct</span> <span class=nc>TiledAlgorithm</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>TiledAlgorithm</span><span class=p>(</span><span class=kt>int</span> <span class=n>tileSize</span><span class=p>,</span> <span class=kt>int</span> <span class=n>padding</span><span class=p>,</span> <span class=kt>int</span> <span class=n>borderType</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=o>:</span> <span class=n>mTileSize</span><span class=p>(</span><span class=n>tileSize</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>,</span> <span class=n>mPadding</span><span class=p>(</span><span class=n>padding</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>,</span> <span class=n>mBorderType</span><span class=p>(</span><span class=n>borderType</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>process</span><span class=p>(</span><span class=k>const</span> <span class=n>cv</span><span class=o>::</span><span class=n>Mat</span><span class=o>&amp;</span> <span class=n>sourceImage</span><span class=p>,</span> <span class=n>cv</span><span class=o>::</span><span class=n>Mat</span><span class=o>&amp;</span> <span class=n>resultImage</span><span class=p>)</span> <span class=k>const</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>assert</span><span class=p>(</span><span class=o>!</span><span class=n>resultImage</span><span class=p>.</span><span class=n>empty</span><span class=p>());</span>
</span></span><span class=line><span class=cl>        <span class=n>assert</span><span class=p>(</span><span class=n>sourceImage</span><span class=p>.</span><span class=n>rows</span> <span class=o>==</span> <span class=n>resultImage</span><span class=p>.</span><span class=n>rows</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>assert</span><span class=p>(</span><span class=n>sourceImage</span><span class=p>.</span><span class=n>cols</span> <span class=o>==</span> <span class=n>resultImage</span><span class=p>.</span><span class=n>cols</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>rows</span> <span class=o>=</span> <span class=p>(</span><span class=n>sourceImage</span><span class=p>.</span><span class=n>rows</span> <span class=o>/</span> <span class=n>mTileSize</span><span class=p>)</span> <span class=o>+</span> <span class=p>(</span><span class=n>sourceImage</span><span class=p>.</span><span class=n>rows</span> <span class=o>%</span> <span class=n>mTileSize</span> <span class=o>?</span> <span class=mi>1</span> <span class=o>:</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>cols</span> <span class=o>=</span> <span class=p>(</span><span class=n>sourceImage</span><span class=p>.</span><span class=n>cols</span> <span class=o>/</span> <span class=n>mTileSize</span><span class=p>)</span> <span class=o>+</span> <span class=p>(</span><span class=n>sourceImage</span><span class=p>.</span><span class=n>cols</span> <span class=o>%</span> <span class=n>mTileSize</span> <span class=o>?</span> <span class=mi>1</span> <span class=o>:</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>cv</span><span class=o>::</span><span class=n>Mat</span> <span class=n>tileInput</span><span class=p>,</span> <span class=n>tileOutput</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>rowTile</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>rowTile</span> <span class=o>&lt;</span> <span class=n>rows</span><span class=p>;</span> <span class=n>rowTile</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>colTile</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>colTile</span> <span class=o>&lt;</span> <span class=n>cols</span><span class=p>;</span> <span class=n>colTile</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>cv</span><span class=o>::</span><span class=n>Rect</span> <span class=n>srcTile</span><span class=p>(</span><span class=n>colTile</span> <span class=o>*</span> <span class=n>mTileSize</span> <span class=o>-</span> <span class=n>mPadding</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>                                 <span class=n>rowTile</span> <span class=o>*</span> <span class=n>mTileSize</span> <span class=o>-</span> <span class=n>mPadding</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>                                 <span class=n>mTileSize</span> <span class=o>+</span> <span class=mi>2</span> <span class=o>*</span> <span class=n>mPadding</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>                                 <span class=n>mTileSize</span> <span class=o>+</span> <span class=mi>2</span> <span class=o>*</span> <span class=n>mPadding</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                <span class=n>cv</span><span class=o>::</span><span class=n>Rect</span> <span class=n>dstTile</span><span class=p>(</span><span class=n>colTile</span> <span class=o>*</span> <span class=n>mTileSize</span><span class=p>,</span>            
</span></span><span class=line><span class=cl>                                 <span class=n>rowTile</span> <span class=o>*</span> <span class=n>mTileSize</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>                                 <span class=n>mTileSize</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>                                 <span class=n>mTileSize</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                <span class=n>copySourceTile</span><span class=p>(</span><span class=n>sourceImage</span><span class=p>,</span> <span class=n>tileInput</span><span class=p>,</span> <span class=n>srcTile</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=n>processTileImpl</span><span class=p>(</span><span class=n>tileInput</span><span class=p>,</span> <span class=n>tileOutput</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=n>copyTileToResultImage</span><span class=p>(</span><span class=n>tileOutput</span><span class=p>,</span> <span class=n>resultImage</span><span class=p>,</span> <span class=n>dstTile</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>protected</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=n>processTileImpl</span><span class=p>(</span><span class=k>const</span> <span class=n>cv</span><span class=o>::</span><span class=n>Mat</span><span class=o>&amp;</span> <span class=n>srcTile</span><span class=p>,</span> <span class=n>cv</span><span class=o>::</span><span class=n>Mat</span><span class=o>&amp;</span> <span class=n>dstTile</span><span class=p>)</span> <span class=k>const</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>copySourceTile</span><span class=p>(</span><span class=k>const</span> <span class=n>cv</span><span class=o>::</span><span class=n>Mat</span><span class=o>&amp;</span> <span class=n>src</span><span class=p>,</span> <span class=n>cv</span><span class=o>::</span><span class=n>Mat</span><span class=o>&amp;</span> <span class=n>srcTile</span><span class=p>,</span> <span class=n>cv</span><span class=o>::</span><span class=n>Rect</span> <span class=o>&amp;</span><span class=n>tile</span><span class=p>)</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>copyTileToResultImage</span><span class=p>(</span><span class=k>const</span> <span class=n>cv</span><span class=o>::</span><span class=n>Mat</span><span class=o>&amp;</span> <span class=n>tileImage</span><span class=p>,</span> <span class=n>cv</span><span class=o>::</span><span class=n>Mat</span><span class=o>&amp;</span> <span class=n>resultImage</span><span class=p>,</span> <span class=n>cv</span><span class=o>::</span><span class=n>Rect</span> <span class=n>resultRoi</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p><img src=processing_with_paddings.png alt="Processing with paddings"></p><p>To fill a tile with source image we should check whether tile is close to image border. In this case OpenCV will come to help with cv::copyMakeBorder function that helps us to fill the missing pixels with given border fill method. If tile including paddings are entirely in the image boundary, it&rsquo;s enough to just copy image region to a tile:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>copySourceTile</span><span class=p>(</span><span class=k>const</span> <span class=n>cv</span><span class=o>::</span><span class=n>Mat</span><span class=o>&amp;</span> <span class=n>src</span><span class=p>,</span> <span class=n>cv</span><span class=o>::</span><span class=n>Mat</span><span class=o>&amp;</span> <span class=n>srcTile</span><span class=p>,</span> <span class=n>cv</span><span class=o>::</span><span class=n>Rect</span> <span class=o>&amp;</span><span class=n>tile</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>auto</span> <span class=n>tl</span> <span class=o>=</span> <span class=n>tile</span><span class=p>.</span><span class=n>tl</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>auto</span> <span class=n>br</span> <span class=o>=</span> <span class=n>tile</span><span class=p>.</span><span class=n>br</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>cv</span><span class=o>::</span><span class=n>Point</span> <span class=n>tloffset</span><span class=p>,</span> <span class=n>broffset</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>//Take care of border cases
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>tile</span><span class=p>.</span><span class=n>x</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>tloffset</span><span class=p>.</span><span class=n>x</span> <span class=o>=</span> <span class=o>-</span><span class=n>tile</span><span class=p>.</span><span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>tile</span><span class=p>.</span><span class=n>x</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>tile</span><span class=p>.</span><span class=n>y</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>tloffset</span><span class=p>.</span><span class=n>y</span> <span class=o>=</span> <span class=o>-</span><span class=n>tile</span><span class=p>.</span><span class=n>y</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>tile</span><span class=p>.</span><span class=n>y</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>br</span><span class=p>.</span><span class=n>x</span> <span class=o>&gt;=</span> <span class=n>src</span><span class=p>.</span><span class=n>cols</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>broffset</span><span class=p>.</span><span class=n>x</span> <span class=o>=</span> <span class=n>br</span><span class=p>.</span><span class=n>x</span> <span class=o>-</span> <span class=n>src</span><span class=p>.</span><span class=n>cols</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>tile</span><span class=p>.</span><span class=n>width</span> <span class=o>-=</span> <span class=n>broffset</span><span class=p>.</span><span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>br</span><span class=p>.</span><span class=n>y</span> <span class=o>&gt;=</span> <span class=n>src</span><span class=p>.</span><span class=n>rows</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>broffset</span><span class=p>.</span><span class=n>y</span> <span class=o>=</span> <span class=n>br</span><span class=p>.</span><span class=n>y</span> <span class=o>-</span> <span class=n>src</span><span class=p>.</span><span class=n>rows</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>tile</span><span class=p>.</span><span class=n>height</span> <span class=o>-=</span> <span class=n>broffset</span><span class=p>.</span><span class=n>y</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// If any of the tile sides exceed source image boundary we must use copyMakeBorder to make proper paddings for this side
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>tloffset</span><span class=p>.</span><span class=n>x</span> <span class=o>&gt;</span> <span class=mi>0</span> <span class=o>||</span> <span class=n>tloffset</span><span class=p>.</span><span class=n>y</span> <span class=o>&gt;</span> <span class=mi>0</span> <span class=o>||</span> <span class=n>broffset</span><span class=p>.</span><span class=n>x</span> <span class=o>&gt;</span> <span class=mi>0</span> <span class=o>||</span> <span class=n>broffset</span><span class=p>.</span><span class=n>y</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>cv</span><span class=o>::</span><span class=n>Rect</span> <span class=n>paddedTile</span><span class=p>(</span><span class=n>tile</span><span class=p>.</span><span class=n>tl</span><span class=p>(),</span> <span class=n>tile</span><span class=p>.</span><span class=n>br</span><span class=p>());</span>
</span></span><span class=line><span class=cl>        <span class=n>assert</span><span class=p>(</span><span class=n>paddedTile</span><span class=p>.</span><span class=n>x</span> <span class=o>&gt;=</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>assert</span><span class=p>(</span><span class=n>paddedTile</span><span class=p>.</span><span class=n>y</span> <span class=o>&gt;=</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>assert</span><span class=p>(</span><span class=n>paddedTile</span><span class=p>.</span><span class=n>br</span><span class=p>().</span><span class=n>x</span> <span class=o>&lt;</span> <span class=n>src</span><span class=p>.</span><span class=n>cols</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>assert</span><span class=p>(</span><span class=n>paddedTile</span><span class=p>.</span><span class=n>br</span><span class=p>().</span><span class=n>y</span> <span class=o>&lt;</span> <span class=n>src</span><span class=p>.</span><span class=n>rows</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>cv</span><span class=o>::</span><span class=n>copyMakeBorder</span><span class=p>(</span><span class=n>src</span><span class=p>(</span><span class=n>paddedTile</span><span class=p>),</span> <span class=n>srcTile</span><span class=p>,</span> <span class=n>tloffset</span><span class=p>.</span><span class=n>y</span><span class=p>,</span> <span class=n>broffset</span><span class=p>.</span><span class=n>y</span><span class=p>,</span> <span class=n>tloffset</span><span class=p>.</span><span class=n>x</span><span class=p>,</span> <span class=n>broffset</span><span class=p>.</span><span class=n>x</span><span class=p>,</span> <span class=n>mBorderType</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Entire tile (with paddings lies inside image and it&#39;s safe to just take a region:
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>src</span><span class=p>(</span><span class=n>tile</span><span class=p>).</span><span class=n>copyTo</span><span class=p>(</span><span class=n>srcTile</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>For non-zero padding case we add additional pixels to source tile, therefore it has effective width and height of <code>TileSize + Padding + Padding</code>, but after processing we write only central segment of the tile of size <code>TileSize x TileSize</code> to destination image. In case of Sobel, we need a padding of <code>1</code>, because Sobel uses 3x3 kernel by default.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>copyTileToResultImage</span><span class=p>(</span><span class=k>const</span> <span class=n>cv</span><span class=o>::</span><span class=n>Mat</span><span class=o>&amp;</span> <span class=n>tileImage</span><span class=p>,</span> <span class=n>cv</span><span class=o>::</span><span class=n>Mat</span><span class=o>&amp;</span> <span class=n>resultImage</span><span class=p>,</span> <span class=n>cv</span><span class=o>::</span><span class=n>Rect</span> <span class=n>resultRoi</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>cv</span><span class=o>::</span><span class=n>Rect</span> <span class=n>srcTile</span><span class=p>(</span><span class=n>mPadding</span><span class=p>,</span> <span class=n>mPadding</span><span class=p>,</span> <span class=n>mTileSize</span><span class=p>,</span> <span class=n>mTileSize</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>auto</span> <span class=n>br</span> <span class=o>=</span> <span class=n>resultRoi</span><span class=p>.</span><span class=n>br</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>br</span><span class=p>.</span><span class=n>x</span> <span class=o>&gt;=</span> <span class=n>resultImage</span><span class=p>.</span><span class=n>cols</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>resultRoi</span><span class=p>.</span><span class=n>width</span> <span class=o>-=</span> <span class=n>br</span><span class=p>.</span><span class=n>x</span> <span class=o>-</span> <span class=n>resultImage</span><span class=p>.</span><span class=n>cols</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>srcTile</span><span class=p>.</span><span class=n>width</span> <span class=o>-=</span> <span class=n>br</span><span class=p>.</span><span class=n>x</span> <span class=o>-</span> <span class=n>resultImage</span><span class=p>.</span><span class=n>cols</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>br</span><span class=p>.</span><span class=n>y</span> <span class=o>&gt;=</span> <span class=n>resultImage</span><span class=p>.</span><span class=n>rows</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>resultRoi</span><span class=p>.</span><span class=n>height</span> <span class=o>-=</span> <span class=n>br</span><span class=p>.</span><span class=n>y</span> <span class=o>-</span> <span class=n>resultImage</span><span class=p>.</span><span class=n>rows</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>srcTile</span><span class=p>.</span><span class=n>height</span> <span class=o>-=</span> <span class=n>br</span><span class=p>.</span><span class=n>y</span> <span class=o>-</span> <span class=n>resultImage</span><span class=p>.</span><span class=n>rows</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>cv</span><span class=o>::</span><span class=n>Mat</span> <span class=n>tileView</span> <span class=o>=</span> <span class=n>tileImage</span><span class=p>(</span><span class=n>srcTile</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>cv</span><span class=o>::</span><span class=n>Mat</span> <span class=n>dstView</span> <span class=o>=</span> <span class=n>resultImage</span><span class=p>(</span><span class=n>resultRoi</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>assert</span><span class=p>(</span><span class=n>tileView</span><span class=p>.</span><span class=n>rows</span> <span class=o>==</span> <span class=n>dstView</span><span class=p>.</span><span class=n>rows</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>assert</span><span class=p>(</span><span class=n>tileView</span><span class=p>.</span><span class=n>cols</span> <span class=o>==</span> <span class=n>dstView</span><span class=p>.</span><span class=n>cols</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>tileView</span><span class=p>.</span><span class=n>copyTo</span><span class=p>(</span><span class=n>dstView</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=application>Application</h2><p>This approach can be used when you need to guarantee low-memory footprint of your algorithm or you want to use data locality without changing a lot in your code. In this
case I suggest to pre-allocate data buffers as a continuous block of memory:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// Our algorithm need three intermediate buffers: a,b,c that
</span></span></span><span class=line><span class=cl><span class=c1>// we want to store close to each other
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>MyAlgorithm</span> <span class=o>:</span> <span class=k>public</span> <span class=n>TiledAlgorithm</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>MyAlgorithm</span><span class=p>(</span><span class=kt>int</span> <span class=n>tileSize</span><span class=p>,</span> <span class=kt>int</span> <span class=n>padding</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>size</span> <span class=o>=</span> <span class=n>tileSize</span> <span class=o>+</span> <span class=n>padding</span> <span class=o>*</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// Allocate all buffer as continuous array
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>mBuffer</span><span class=p>.</span><span class=n>create</span><span class=p>(</span><span class=n>size</span> <span class=o>*</span> <span class=mi>3</span><span class=p>,</span> <span class=n>size</span><span class=p>,</span> <span class=n>CV_8UC1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>        <span class=c1>// Create views to sub-regions of mBuffer
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>a</span> <span class=o>=</span> <span class=n>mBuffer</span><span class=p>.</span><span class=n>rowRange</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span>      <span class=n>size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>b</span> <span class=o>=</span> <span class=n>mBuffer</span><span class=p>.</span><span class=n>rowRange</span><span class=p>(</span><span class=n>size</span><span class=p>,</span>   <span class=mi>2</span><span class=o>*</span><span class=n>size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>c</span> <span class=o>=</span> <span class=n>mBuffer</span><span class=p>.</span><span class=n>rowRange</span><span class=p>(</span><span class=mi>2</span><span class=o>*</span><span class=n>size</span><span class=p>,</span> <span class=mi>3</span><span class=o>*</span><span class=n>size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>cv</span><span class=o>::</span><span class=n>Mat</span> <span class=n>mBuffer</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>cv</span><span class=o>::</span><span class=n>Mat</span> <span class=n>a</span><span class=p>,</span> <span class=n>b</span> <span class=n>c</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Did you know, that JPEG-2000 coded use tile-based encoding and it allows this codec to retrieve (decode) an arbitrary region of the image? Also, tiles are widely used in aerial photography to stich images.</p><p>I hope you find this post interesting. Pleas let me know on which topics you would like to see in my blog. Feel free to drop a ping on <a href=https://twitter.com/cvtalks>@cvtalks</a> or leave a comment. Thanks!</p></div><div class=post__footer><span><a class=tag href=/tags/opencv/>opencv</a><a class=tag href=/tags/tutorials/>tutorials</a><a class=tag href=/tags/algorithms/>algorithms</a></span></div><div id=comment><h2>comments</h2><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//cvtalks.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></div></main></div><footer class="footer footer__base"><ul class=footer__list><li class=footer__item>&copy;
Eugene Khvedchenya
2022</li></ul></footer><script type=text/javascript src=/js/medium-zoom.min.9c062c557275acbaba71f0c7cd4024da3e3cc825d248bc4b2130811b0965330b.js integrity="sha256-nAYsVXJ1rLq6cfDHzUAk2j48yCXSSLxLITCBGwllMws=" crossorigin=anonymous></script>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-10687369-5","auto"),ga("send","pageview"))</script><script async src=https://www.google-analytics.com/analytics.js></script></body></html>