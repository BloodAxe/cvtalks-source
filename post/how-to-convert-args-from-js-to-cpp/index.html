<!doctype html><html dir=ltr lang=en data-theme class=html><head><title>Eugene Khvedchenya
|
Argument checking for native addons for Node.js. Do it right!</title><meta charset=utf-8><meta name=generator content="Hugo 0.98.0"><meta name=viewport content="width=device-width,initial-scale=1,viewport-fit=cover"><meta name=author content="Eugene Khvedchenya"><meta name=description content="A personal blog about Computer Vision, AI, Kaggle, Open-Source and research. You will never read this in books."><link rel=stylesheet href=/scss/main.min.b2e0cb07595e3519ab1193bb421914e06c0e26b0cc561fef23b3c6131d4d2ffa.css integrity="sha256-suDLB1leNRmrEZO7QhkU4GwOJrDMVh/vI7PGEx1NL/o=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/css/markupHighlight.min.31b0a1f317f55c529a460897848c97436bb138b19c399b37de70d463a8bf6ed5.css integrity="sha256-MbCh8xf1XFKaRgiXhIyXQ2uxOLGcOZs33nDUY6i/btU=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/fontawesome/css/fontawesome.min.7d272de35b410fb165377550cdf9c4d3a80fbbcc961e111914e4d5c0eaf5729f.css integrity="sha256-fSct41tBD7FlN3VQzfnE06gPu8yWHhEZFOTVwOr1cp8=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/fontawesome/css/solid.min.55d8333481b07a08e07cf6f37319753a2b47e99f4c395394c5747b48b495aa9b.css integrity="sha256-VdgzNIGwegjgfPbzcxl1OitH6Z9MOVOUxXR7SLSVqps=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/fontawesome/css/regular.min.a7448d02590b43449364b6b5922ed9af5410abb4de4238412a830316dedb850b.css integrity="sha256-p0SNAlkLQ0STZLa1ki7Zr1QQq7TeQjhBKoMDFt7bhQs=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/fontawesome/css/brands.min.9ed75a5d670c953fe4df935937674b4646f92674367e9e66eb995bb04e821647.css integrity="sha256-ntdaXWcMlT/k35NZN2dLRkb5JnQ2fp5m65lbsE6CFkc=" crossorigin=anonymous type=text/css><link rel="shortcut icon" href=/favicon.ico type=image/x-icon><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=canonical href=https://computer-vision-talks.com/post/how-to-convert-args-from-js-to-cpp/><script type=text/javascript src=/js/anatole-header.min.f9132794301a01ff16550ed66763482bd848f62243d278f5e550229a158bfd32.js integrity="sha256-+RMnlDAaAf8WVQ7WZ2NIK9hI9iJD0nj15VAimhWL/TI=" crossorigin=anonymous></script>
<script type=text/javascript src=/js/anatole-theme-switcher.min.560a26330d27ff44a44e83b53cd07a95d4230a65930d31c5c76a8d481e5b35bf.js integrity="sha256-VgomMw0n/0SkToO1PNB6ldQjCmWTDTHFx2qNSB5bNb8=" crossorigin=anonymous></script><meta name=twitter:card content="summary"><meta name=twitter:title content="Argument checking for native addons for Node.js. Do it right!"><meta name=twitter:description content="During development of CloudCV I came to the problem on converting v8::Arguments to native C++ data types in my Node.js native module. If you are new to C++ and Node.js, I suggest you to read how to write C++ modules for Node.js and connecting OpenCV and Node.js first.
Mapping V8 data types to native C++ equivalents is trivial, but somewhat wordy. One should take the argument at given index, check whether it is defined, then check it&rsquo;s type and finally cast to C++ type."><meta property="og:title" content="Argument checking for native addons for Node.js. Do it right!"><meta property="og:description" content="During development of CloudCV I came to the problem on converting v8::Arguments to native C++ data types in my Node.js native module. If you are new to C++ and Node.js, I suggest you to read how to write C++ modules for Node.js and connecting OpenCV and Node.js first.
Mapping V8 data types to native C++ equivalents is trivial, but somewhat wordy. One should take the argument at given index, check whether it is defined, then check it&rsquo;s type and finally cast to C++ type."><meta property="og:type" content="article"><meta property="og:url" content="https://computer-vision-talks.com/post/how-to-convert-args-from-js-to-cpp/"><meta property="article:section" content="post"><meta property="article:published_time" content="2014-09-11T00:00:00+00:00"><meta property="article:modified_time" content="2014-09-11T00:00:00+00:00"><meta property="og:site_name" content="Computer Vision Talks"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","articleSection":"post","name":"Argument checking for native addons for Node.js. Do it right!","headline":"Argument checking for native addons for Node.js. Do it right!","alternativeHeadline":"","description":"
      
        During development of CloudCV I came to the problem on converting v8::Arguments to native C\u002b\u002b data types in my Node.js native module. If you are new to C\u002b\u002b and Node.js, I suggest you to read how to write C\u002b\u002b modules for Node.js and connecting OpenCV and Node.js first.\nMapping V8 data types to native C\u002b\u002b equivalents is trivial, but somewhat wordy. One should take the argument at given index, check whether it is defined, then check it\u0026rsquo;s type and finally cast to C\u002b\u002b type.


      


    ","inLanguage":"en-us","isFamilyFriendly":"true","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/computer-vision-talks.com\/post\/how-to-convert-args-from-js-to-cpp\/"},"author":{"@type":"Person","name":"Eugene Khvedchenya"},"creator":{"@type":"Person","name":"Eugene Khvedchenya"},"accountablePerson":{"@type":"Person","name":"Eugene Khvedchenya"},"copyrightHolder":{"@type":"Person","name":"Eugene Khvedchenya"},"copyrightYear":"2014","dateCreated":"2014-09-11T00:00:00.00Z","datePublished":"2014-09-11T00:00:00.00Z","dateModified":"2014-09-11T00:00:00.00Z","publisher":{"@type":"Organization","name":"Eugene Khvedchenya","url":"https://computer-vision-talks.com/","logo":{"@type":"ImageObject","url":"https:\/\/computer-vision-talks.com\/favicon-32x32.png","width":"32","height":"32"}},"image":[],"url":"https:\/\/computer-vision-talks.com\/post\/how-to-convert-args-from-js-to-cpp\/","wordCount":"1224","genre":[],"keywords":["cloudcv","nodejs","tutorials"]}</script></head><body class="body theme--light"><div class=wrapper><aside class=wrapper__sidebar><div class="sidebar
animated fadeInDown"><div class=sidebar__content><div class=sidebar__introduction><img class=sidebar__introduction-profileimage src=/images/4ECfkGJr_400x400.jpg alt="profile picture"><div class=sidebar__introduction-title><a href=/>Computer Vision Talks</a></div><div class=sidebar__introduction-description><p>A personal blog about Computer Vision, AI, Kaggle, Open-Source and research. You will never read this in books.</p></div></div><ul class=sidebar__list><li class=sidebar__list-item><a href=https://www.linkedin.com/in/cvtalks/ target=_blank rel=noopener aria-label=Linkedin title=Linkedin><i class="fab fa-linkedin fa-2x" aria-hidden=true></i></a></li><li class=sidebar__list-item><a href=https://twitter.com/cvtalks target=_blank rel=noopener aria-label=Twitter title=Twitter><i class="fab fa-twitter fa-2x" aria-hidden=true></i></a></li><li class=sidebar__list-item><a href=https://github.com/BloodAxe target=_blank rel=noopener aria-label=GitHub title=GitHub><i class="fab fa-github fa-2x" aria-hidden=true></i></a></li><li class=sidebar__list-item><a href=mailto:ekhvedchenya@computer-vision-talks.com target=_blank rel=noopener aria-label=E-Mail title=E-Mail><i class="fas fa-envelope fa-2x" aria-hidden=true></i></a></li></ul></div><footer class="footer footer__sidebar"><ul class=footer__list><li class=footer__item>&copy;
Eugene Khvedchenya
2022</li></ul></footer><script type=text/javascript src=/js/medium-zoom.min.9c062c557275acbaba71f0c7cd4024da3e3cc825d248bc4b2130811b0965330b.js integrity="sha256-nAYsVXJ1rLq6cfDHzUAk2j48yCXSSLxLITCBGwllMws=" crossorigin=anonymous></script>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-10687369-5","auto"),ga("send","pageview"))</script><script async src=https://www.google-analytics.com/analytics.js></script></div></aside><main class=wrapper__main><header class=header><div class="animated fadeInDown"><a role=button class=navbar-burger data-target=navMenu aria-label=menu aria-expanded=false><span aria-hidden=true class=navbar-burger__line></span>
<span aria-hidden=true class=navbar-burger__line></span>
<span aria-hidden=true class=navbar-burger__line></span></a><nav class=nav><ul class=nav__list id=navMenu><li class=nav__list-item><a href=/ title>Home</a></li><li class=nav__list-item><a href=/post/ title>Posts</a></li><li class=nav__list-item><a href=/open-source title>Open-Source</a></li><li class=nav__list-item><a href=/challenges title>Wins</a></li><li class=nav__list-item><a href=/publications title>Publications</a></li></ul><ul class="nav__list nav__list--end"><li class=nav__list-item><div class=themeswitch><a title="Switch Theme"><i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></li></ul></nav></div></header><div class="post
animated fadeInDown"><div class=post__content><h1>Argument Checking for Native Addons for Node.js. Do It Right!</h1><ul class=post__meta><li class=post__meta-item><em class="fas fa-calendar-day post__meta-icon"></em>
<span class=post__meta-text>Thu, Sep 11, 2014</span></li><li class=post__meta-item><em class="fas fa-stopwatch post__meta-icon"></em>
<span class=post__meta-text>6-minute read</span></li></ul><p>During development of <a href=https://cloudcv.io>CloudCV</a> I came to the problem on converting <code>v8::Arguments</code> to
native C++ data types in my Node.js native module. If you are new to C++ and Node.js, I suggest you to read how to write C++ modules for Node.js and connecting OpenCV and Node.js first.</p><p>Mapping V8 data types to native C++ equivalents is trivial, but somewhat wordy. One should take the
argument at given index, check whether it is defined, then check it&rsquo;s type and finally cast to C++ type.
This works fine while you have function that receive two or three arguments of trivial type (That can be mapped directly to built-in C++ types). What about strings? Arrays? Complex types like objects or function callback?
You code will grow like and became hard-to-maintain pasta-code some day.</p><p>In this post I present my approach on solving this problem with a laconic way on describing what do you expect as input arguments.</p><p></p><p>To illustrate the difference between imperative approach I included source code for calibrationPatternDetect method that expose function to detect calibration pattern on a single image to Node.js code. As you may see below, there are a lot of <em>if</em> conditions, magic numbers and no type checking for a half of arguments. But even without it, this function occupy 50 lines of code.
What even worse, 90% of this code is going to be the same for other functions. The main purpose of code of any <code>NAN_METHOD</code> implementation - to marshal data in such a way it can be used by C++ code.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>NAN_METHOD</span><span class=p>(</span><span class=n>calibrationPatternDetect</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>NanScope</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>args</span><span class=p>.</span><span class=n>Length</span><span class=p>()</span> <span class=o>!=</span> <span class=mi>5</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nf>NanThrowError</span><span class=p>(</span><span class=s>&#34;Invalid number of arguments&#34;</span><span class=p>);</span>  
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>args</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span><span class=o>-&gt;</span><span class=n>IsObject</span><span class=p>())</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nf>NanThrowTypeError</span><span class=p>(</span><span class=s>&#34;First argument should be a Buffer&#34;</span><span class=p>);</span>      
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 0 - image
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 1 - width
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 2 - height
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 3 - pattern
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 4 - callback
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>w</span>  <span class=o>=</span> <span class=n>args</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span><span class=o>-&gt;</span><span class=n>Uint32Value</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>h</span>  <span class=o>=</span> <span class=n>args</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span><span class=o>-&gt;</span><span class=n>Uint32Value</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>pt</span> <span class=o>=</span> <span class=n>args</span><span class=p>[</span><span class=mi>3</span><span class=p>]</span><span class=o>-&gt;</span><span class=n>Uint32Value</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>PatternType</span> <span class=n>pattern</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>switch</span> <span class=p>(</span><span class=n>pt</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=mi>0</span><span class=o>:</span>
</span></span><span class=line><span class=cl>            <span class=n>pattern</span> <span class=o>=</span> <span class=n>CHESSBOARD</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=mi>1</span><span class=o>:</span>
</span></span><span class=line><span class=cl>            <span class=n>pattern</span> <span class=o>=</span> <span class=n>CIRCLES_GRID</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=mi>2</span><span class=o>:</span>
</span></span><span class=line><span class=cl>            <span class=n>pattern</span> <span class=o>=</span> <span class=n>ASYMMETRIC_CIRCLES_GRID</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>break</span><span class=p>;</span>    
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>default</span><span class=o>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>NanThrowError</span><span class=p>(</span><span class=s>&#34;Unsupported pattern type. Only 0 (CHESSBOARD), 1 (CIRCLES_GRID) or 2 (ASYMMETRIC_CIRCLES_GRID) are supported.&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>args</span><span class=p>[</span><span class=mi>4</span><span class=p>]</span><span class=o>-&gt;</span><span class=n>IsFunction</span><span class=p>())</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nf>NanThrowTypeError</span><span class=p>(</span><span class=s>&#34;Last argument must be a function.&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// The task holds our custom status information for this asynchronous call,
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// like the callback function we want to call when returning to the main
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// thread and the status information.
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=n>NanCallback</span> <span class=o>*</span><span class=n>callback</span> <span class=o>=</span> <span class=k>new</span> <span class=n>NanCallback</span><span class=p>(</span><span class=n>args</span><span class=p>[</span><span class=mi>4</span><span class=p>].</span><span class=n>As</span><span class=o>&lt;</span><span class=n>Function</span><span class=o>&gt;</span><span class=p>());</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>So the goal is to add more syntax sugar for argument checking.
Basically, it should provide a convenient way to check number and type of arguments passed.
For <a href=https://cloudcv.io>CloudCV</a> project I&rsquo;ve ended with a declarative approach because I found it fit my needs very much
and makes argument checking self-explanatory. Here is how new implementation of <code>calibrationPatternDetect</code> looks like:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>NAN_METHOD</span><span class=p>(</span><span class=n>calibrationPatternDetect</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>NanScope</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>Local</span><span class=o>&lt;</span><span class=n>Object</span><span class=o>&gt;</span>   <span class=n>imageBuffer</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Local</span><span class=o>&lt;</span><span class=n>Function</span><span class=o>&gt;</span> <span class=n>callback</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>cv</span><span class=o>::</span><span class=n>Size</span>        <span class=n>patternSize</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>PatternType</span>     <span class=n>pattern</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>try</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>NanCheck</span><span class=p>(</span><span class=n>args</span><span class=p>).</span><span class=n>ArgumentsCount</span><span class=p>(</span><span class=mi>5</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>.</span><span class=n>Argument</span><span class=p>(</span><span class=mi>0</span><span class=p>).</span><span class=n>IsBuffer</span><span class=p>().</span><span class=n>Bind</span><span class=p>(</span><span class=n>imageBuffer</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>.</span><span class=n>Argument</span><span class=p>(</span><span class=mi>1</span><span class=p>).</span><span class=n>Bind</span><span class=p>(</span><span class=n>patternSize</span><span class=p>.</span><span class=n>width</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>.</span><span class=n>Argument</span><span class=p>(</span><span class=mi>2</span><span class=p>).</span><span class=n>Bind</span><span class=p>(</span><span class=n>patternSize</span><span class=p>.</span><span class=n>height</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>.</span><span class=n>Argument</span><span class=p>(</span><span class=mi>3</span><span class=p>).</span><span class=n>StringEnum</span><span class=o>&lt;</span><span class=n>PatternType</span><span class=o>&gt;</span><span class=p>({</span> 
</span></span><span class=line><span class=cl>                <span class=p>{</span> <span class=s>&#34;CHESSBOARD&#34;</span><span class=p>,</span>     <span class=n>PatternType</span><span class=o>::</span><span class=n>CHESSBOARD</span> <span class=p>},</span> 
</span></span><span class=line><span class=cl>                <span class=p>{</span> <span class=s>&#34;CIRCLES_GRID&#34;</span><span class=p>,</span>   <span class=n>PatternType</span><span class=o>::</span><span class=n>CIRCLES_GRID</span> <span class=p>},</span> 
</span></span><span class=line><span class=cl>                <span class=p>{</span> <span class=s>&#34;ACIRCLES_GRID&#34;</span><span class=p>,</span>  <span class=n>PatternType</span><span class=o>::</span><span class=n>ACIRCLES_GRID</span> <span class=p>}</span> <span class=p>}).</span><span class=n>Bind</span><span class=p>(</span><span class=n>pattern</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>.</span><span class=n>Argument</span><span class=p>(</span><span class=mi>4</span><span class=p>).</span><span class=n>IsFunction</span><span class=p>().</span><span class=n>Bind</span><span class=p>(</span><span class=n>callback</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>NanCallback</span> <span class=o>*</span><span class=n>nanCallback</span> <span class=o>=</span> <span class=k>new</span> <span class=n>NanCallback</span><span class=p>(</span><span class=n>callback</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>NanAsyncQueueWorker</span><span class=p>(</span><span class=k>new</span> <span class=n>DetectPatternTask</span><span class=p>(</span><span class=n>imageBuffer</span><span class=p>,</span> <span class=n>patternSize</span><span class=p>,</span> <span class=n>pattern</span><span class=p>,</span> <span class=n>nanCallback</span><span class=p>));</span>
</span></span><span class=line><span class=cl>            <span class=n>NanReturnValue</span><span class=p>(</span><span class=n>NanTrue</span><span class=p>());</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>NanReturnValue</span><span class=p>(</span><span class=n>NanFalse</span><span class=p>());</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>catch</span> <span class=p>(</span><span class=n>ArgumentMismatchException</span> <span class=n>exc</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nf>NanThrowTypeError</span><span class=p>(</span><span class=n>exc</span><span class=p>.</span><span class=n>what</span><span class=p>());</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>I hope you agree that second version is much more easy to read. Fluent architecture allows to write predicates in a chain, which actually is very similar to the way we thing. All predicate has self-telling names made from verb and a noun. So let me give you a brief overview what <code>NanCheck</code> is capable of.</p><h2 id=fluent-api>Fluent API</h2><p><a href=http://en.wikipedia.org/wiki/Method_chaining>Method chaining</a> (aka Fluent API) makes it very easy to build final predicate for argument checking via consecutive checks.
Each next step will be made <strong>if and only if</strong> all previous predicates were successful.
In case of error, predicate will throw an <code>ArgumentMismatchException</code> exception that will terminate all further checks. <code>NanCheck(args)</code> can be evaluated to <code>bool</code> which makes it possible to use NanCheck in a condition statement:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>NanCheck</span><span class=p>(</span><span class=n>args</span><span class=p>).</span> <span class=p>...)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// This code will be executed if argument parsing
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// will be successful        
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><h2 id=type-checking>Type checking</h2><p>To check particular argument at given index, <code>NanCheckArguments</code> provide a <code>Argument(index)</code> function. This function lets you to build a sub-predicate for given argument and bind it&rsquo;s value with particular local variable:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>NanCheck</span><span class=p>(</span><span class=n>args</span><span class=p>).</span><span class=n>Argument</span><span class=p>(</span><span class=mi>0</span><span class=p>).</span><span class=n>IsBuffer</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// This code will be executed if argument parsing
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// will be successful        
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span></code></pre></div><p>Currently, <code>NanCheck</code> support type checking of the following built-in V8 types:</p><ol><li><code>v8::Function</code></li><li><code>v8::Object</code></li><li><code>v8::String</code></li></ol><p>In addition, it offers <code>NotNull</code> predicate to ensure argument is not null or empty.
The list of predicates will grow for sure. New functions to check whether argument is <code>v8::Array</code>, <code>v8::Number</code>, <code>v8::Integer</code>, <code>v8::Boolean</code> will be added in a next updates.</p><h2 id=binding>Binding</h2><p>After type checking, it&rsquo;s necessary to complete sub-predicate construction by <em>binding</em> argument to a local variable. Binding is a assignment of the argument (with data marshaling, if it&rsquo;s necessary) to a variable that will be used later;</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl>    <span class=n>Local</span><span class=o>&lt;</span><span class=n>Object</span><span class=o>&gt;</span>   <span class=n>imageBuffer</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>NanCheck</span><span class=p>(</span><span class=n>args</span><span class=p>).</span><span class=n>Argument</span><span class=p>(</span><span class=mi>0</span><span class=p>).</span><span class=n>IsBuffer</span><span class=p>().</span><span class=n>Bind</span><span class=p>(</span><span class=n>imageBuffer</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// This code will be executed if argument parsing
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// will be successful        
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span></code></pre></div><p>NanCheck support transparent binding to all v8 types (Number, String, Function, Object, Array, etc.), native C++ and OpenCV types (via <a href=https://github.com/BloodAxe/CloudCVBackend/blob/master/src/framework/marshal/opencv.cpp>marshaling system</a>):</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl>    <span class=n>cv</span><span class=o>::</span><span class=n>Size</span>        <span class=n>patternSize</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>NanCheck</span><span class=p>(</span><span class=n>args</span><span class=p>).</span><span class=n>Argument</span><span class=p>(</span><span class=mi>1</span><span class=p>).</span><span class=n>IsObject</span><span class=p>().</span><span class=n>Bind</span><span class=p>(</span><span class=n>patternSize</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// This code will be executed if argument parsing
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// will be successful        
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span></code></pre></div><p>There is a special case of string arguments called <code>StringEnum</code> - that is, a string argument, which can be one of a priory defined values. It introduced to support *<em>C++ enum</em> types and pass them
as string constants. <code>StringEnum</code> predicate allow to parse string value and map to C++ enum type:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl>    <span class=n>PatternType</span>     <span class=n>pattern</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>NanCheck</span><span class=p>(</span><span class=n>args</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>.</span><span class=n>Argument</span><span class=p>(</span><span class=mi>3</span><span class=p>).</span><span class=n>StringEnum</span><span class=o>&lt;</span><span class=n>PatternType</span><span class=o>&gt;</span><span class=p>({</span> 
</span></span><span class=line><span class=cl>            <span class=p>{</span> <span class=s>&#34;CHESSBOARD&#34;</span><span class=p>,</span>     <span class=n>PatternType</span><span class=o>::</span><span class=n>CHESSBOARD</span> <span class=p>},</span> 
</span></span><span class=line><span class=cl>            <span class=p>{</span> <span class=s>&#34;CIRCLES_GRID&#34;</span><span class=p>,</span>   <span class=n>PatternType</span><span class=o>::</span><span class=n>CIRCLES_GRID</span> <span class=p>},</span> 
</span></span><span class=line><span class=cl>            <span class=p>{</span> <span class=s>&#34;ACIRCLES_GRID&#34;</span><span class=p>,</span>  <span class=n>PatternType</span><span class=o>::</span><span class=n>ACIRCLES_GRID</span> <span class=p>}</span> <span class=p>}).</span><span class=n>Bind</span><span class=p>(</span><span class=n>pattern</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// This code will be executed if argument parsing
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// will be successful        
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span></code></pre></div><h2 id=implementation-highlights>Implementation highlights</h2><p>Thanks to C++11, it&rsquo;s really easy to construct predicate chain using lambda functions. Basically predicate chain is nothing but a recursive anonymous function of the following form:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl>    <span class=k>auto</span> <span class=n>initFn</span> <span class=o>=</span> <span class=p>[</span><span class=n>innerPredicate</span><span class=p>,</span> <span class=n>outerPredicate</span><span class=p>](</span><span class=k>const</span> <span class=n>v8</span><span class=o>::</span><span class=n>Arguments</span><span class=o>&amp;</span> <span class=n>args</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nf>innerPredicate</span><span class=p>(</span><span class=n>args</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=n>outerPredicate</span><span class=p>(</span><span class=n>args</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>};</span>
</span></span></code></pre></div><p>To illustrate an idea of building predicate chain, let&rsquo;s take a look on ArgumentsCount implementation:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl>    <span class=n>NanCheckArguments</span><span class=o>&amp;</span> <span class=n>NanCheckArguments</span><span class=o>::</span><span class=n>ArgumentsCount</span><span class=p>(</span><span class=kt>int</span> <span class=n>count</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nf>AddAndClause</span><span class=p>([</span><span class=n>count</span><span class=p>](</span><span class=k>const</span> <span class=n>v8</span><span class=o>::</span><span class=n>Arguments</span><span class=o>&amp;</span> <span class=n>args</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>        <span class=p>{</span> 
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>args</span><span class=p>.</span><span class=n>Length</span><span class=p>()</span> <span class=o>!=</span> <span class=n>count</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=k>throw</span> <span class=n>ArgumentMismatchException</span><span class=p>(</span><span class=n>args</span><span class=p>.</span><span class=n>Length</span><span class=p>(),</span> <span class=n>count</span><span class=p>);</span> 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>});</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span></code></pre></div><p>Here we construct outer predicate which compare number of arguments to expected value
and throw an exception if it does not match.</p><p>With a help of <code>std::initializer_list</code> it became really simple to declare string enum with minimal syntax overhead:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl>    <span class=k>class</span> <span class=nc>NanMethodArgBinding</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>        <span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>        <span class=n>NanArgStringEnum</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> 
</span></span><span class=line><span class=cl>        <span class=n>StringEnum</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>initializer_list</span><span class=o>&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>pair</span><span class=o>&lt;</span><span class=k>const</span> <span class=kt>char</span><span class=o>*</span><span class=p>,</span> <span class=n>T</span><span class=o>&gt;</span> <span class=o>&gt;</span> <span class=n>possibleValues</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=p>};</span>
</span></span></code></pre></div><p>Now we&rsquo;re able to call this function with arbitrary number of elements for this enum using
<code>std::initializer_list</code> syntax:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl>    <span class=p>{</span> 
</span></span><span class=line><span class=cl>        <span class=p>{</span> <span class=s>&#34;CHESSBOARD&#34;</span><span class=p>,</span>     <span class=n>PatternType</span><span class=o>::</span><span class=n>CHESSBOARD</span> <span class=p>},</span> 
</span></span><span class=line><span class=cl>        <span class=p>{</span> <span class=s>&#34;CIRCLES_GRID&#34;</span><span class=p>,</span>   <span class=n>PatternType</span><span class=o>::</span><span class=n>CIRCLES_GRID</span> <span class=p>},</span> 
</span></span><span class=line><span class=cl>        <span class=p>{</span> <span class=s>&#34;ACIRCLES_GRID&#34;</span><span class=p>,</span>  <span class=n>PatternType</span><span class=o>::</span><span class=n>ACIRCLES_GRID</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span></code></pre></div><h2 id=conclusion>Conclusion</h2><p><a href=https://github.com/BloodAxe/CloudCVBackend/blob/master/src/framework/NanCheck.hpp><strong>NanCheck</strong></a> helped me to reduce amount of code required to check arguments passed to <a href=https://cloudcv.io>CloudCV</a> back-end. There are many cool ideas that I&rsquo;ll probably add as soon as there will be necessity to have them in my library:</p><ul><li>Strongly typed objects (Objects with required fields)</li><li>Optional parameters with default values</li><li>Automatic type inference based on <code>Bind&lt;T>(...)</code> type.</li><li>Support of multiple types per argument (Parameter can be either of type A or B)</li></ul><p>Please leave your comments on this post. I&rsquo;ve spent many hours on figuring out how to implement data marshaling and type checking in V8 and Node.js, so please help information to
spread out - share and re-tweet this post. Cheers!</p></div><div class=post__footer><span><a class=tag href=/tags/cloudcv/>cloudcv</a><a class=tag href=/tags/nodejs/>nodejs</a><a class=tag href=/tags/tutorials/>tutorials</a></span></div><div id=comment><h2>comments</h2><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//cvtalks.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></div></main></div><footer class="footer footer__base"><ul class=footer__list><li class=footer__item>&copy;
Eugene Khvedchenya
2022</li></ul></footer><script type=text/javascript src=/js/medium-zoom.min.9c062c557275acbaba71f0c7cd4024da3e3cc825d248bc4b2130811b0965330b.js integrity="sha256-nAYsVXJ1rLq6cfDHzUAk2j48yCXSSLxLITCBGwllMws=" crossorigin=anonymous></script>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-10687369-5","auto"),ga("send","pageview"))</script><script async src=https://www.google-analytics.com/analytics.js></script></body></html>