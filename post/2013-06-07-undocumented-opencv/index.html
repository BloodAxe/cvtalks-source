<!doctype html><html dir=ltr lang=en data-theme class=html><head><title>Eugene Khvedchenya
|
Undocumented OpenCV</title><meta charset=utf-8><meta name=generator content="Hugo 0.98.0"><meta name=viewport content="width=device-width,initial-scale=1,viewport-fit=cover"><meta name=author content="Eugene Khvedchenya"><meta name=description content="A personal blog about Computer Vision, AI, Kaggle, Open-Source and research. You will never read this in books."><link rel=stylesheet href=/scss/main.min.b2e0cb07595e3519ab1193bb421914e06c0e26b0cc561fef23b3c6131d4d2ffa.css integrity="sha256-suDLB1leNRmrEZO7QhkU4GwOJrDMVh/vI7PGEx1NL/o=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/css/markupHighlight.min.31b0a1f317f55c529a460897848c97436bb138b19c399b37de70d463a8bf6ed5.css integrity="sha256-MbCh8xf1XFKaRgiXhIyXQ2uxOLGcOZs33nDUY6i/btU=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/fontawesome/css/fontawesome.min.7d272de35b410fb165377550cdf9c4d3a80fbbcc961e111914e4d5c0eaf5729f.css integrity="sha256-fSct41tBD7FlN3VQzfnE06gPu8yWHhEZFOTVwOr1cp8=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/fontawesome/css/solid.min.55d8333481b07a08e07cf6f37319753a2b47e99f4c395394c5747b48b495aa9b.css integrity="sha256-VdgzNIGwegjgfPbzcxl1OitH6Z9MOVOUxXR7SLSVqps=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/fontawesome/css/regular.min.a7448d02590b43449364b6b5922ed9af5410abb4de4238412a830316dedb850b.css integrity="sha256-p0SNAlkLQ0STZLa1ki7Zr1QQq7TeQjhBKoMDFt7bhQs=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/fontawesome/css/brands.min.9ed75a5d670c953fe4df935937674b4646f92674367e9e66eb995bb04e821647.css integrity="sha256-ntdaXWcMlT/k35NZN2dLRkb5JnQ2fp5m65lbsE6CFkc=" crossorigin=anonymous type=text/css><link rel="shortcut icon" href=/favicon.ico type=image/x-icon><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=canonical href=https://computer-vision-talks.com/post/2013-06-07-undocumented-opencv/><script type=text/javascript src=/js/anatole-header.min.f9132794301a01ff16550ed66763482bd848f62243d278f5e550229a158bfd32.js integrity="sha256-+RMnlDAaAf8WVQ7WZ2NIK9hI9iJD0nj15VAimhWL/TI=" crossorigin=anonymous></script>
<script type=text/javascript src=/js/anatole-theme-switcher.min.560a26330d27ff44a44e83b53cd07a95d4230a65930d31c5c76a8d481e5b35bf.js integrity="sha256-VgomMw0n/0SkToO1PNB6ldQjCmWTDTHFx2qNSB5bNb8=" crossorigin=anonymous></script><meta name=twitter:card content="summary"><meta name=twitter:title content="Undocumented OpenCV"><meta name=twitter:description content="OpenCV library is widely used by computer vision engineers across the world. It contains almost all algorithms you may want for R&D or product development. It has production-ready build farm with tests and strong community that give nice feedbacks and discover errors. But nevertheless OpenCV has some strange issues and undocummented behaviour that can surprise you as minimum and crash your app as maximum.
How to get diagonal matrix in OpenCV A typical parameter update computation in non-linear optimization using Levenber-Marquardt algorithm looks like this:"><meta property="og:title" content="Undocumented OpenCV"><meta property="og:description" content="OpenCV library is widely used by computer vision engineers across the world. It contains almost all algorithms you may want for R&D or product development. It has production-ready build farm with tests and strong community that give nice feedbacks and discover errors. But nevertheless OpenCV has some strange issues and undocummented behaviour that can surprise you as minimum and crash your app as maximum.
How to get diagonal matrix in OpenCV A typical parameter update computation in non-linear optimization using Levenber-Marquardt algorithm looks like this:"><meta property="og:type" content="article"><meta property="og:url" content="https://computer-vision-talks.com/post/2013-06-07-undocumented-opencv/"><meta property="article:section" content="post"><meta property="article:published_time" content="2013-06-07T00:00:00+00:00"><meta property="article:modified_time" content="2013-06-07T00:00:00+00:00"><meta property="og:site_name" content="Computer Vision Talks"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","articleSection":"post","name":"Undocumented OpenCV","headline":"Undocumented OpenCV","alternativeHeadline":"","description":"
      
        OpenCV library is widely used by computer vision engineers across the world. It contains almost all algorithms you may want for R\u0026amp;D or product development. It has production-ready build farm with tests and strong community that give nice feedbacks and discover errors. But nevertheless OpenCV has some strange issues and undocummented behaviour that can surprise you as minimum and crash your app as maximum.\nHow to get diagonal matrix in OpenCV A typical parameter update computation in non-linear optimization using Levenber-Marquardt algorithm looks like this:


      


    ","inLanguage":"en-us","isFamilyFriendly":"true","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/computer-vision-talks.com\/post\/2013-06-07-undocumented-opencv\/"},"author":{"@type":"Person","name":"Eugene Khvedchenya"},"creator":{"@type":"Person","name":"Eugene Khvedchenya"},"accountablePerson":{"@type":"Person","name":"Eugene Khvedchenya"},"copyrightHolder":{"@type":"Person","name":"Eugene Khvedchenya"},"copyrightYear":"2013","dateCreated":"2013-06-07T00:00:00.00Z","datePublished":"2013-06-07T00:00:00.00Z","dateModified":"2013-06-07T00:00:00.00Z","publisher":{"@type":"Organization","name":"Eugene Khvedchenya","url":"https://computer-vision-talks.com/","logo":{"@type":"ImageObject","url":"https:\/\/computer-vision-talks.com\/favicon-32x32.png","width":"32","height":"32"}},"image":[],"url":"https:\/\/computer-vision-talks.com\/post\/2013-06-07-undocumented-opencv\/","wordCount":"509","genre":[],"keywords":["opencv"]}</script></head><body class="body theme--light"><div class=wrapper><aside class=wrapper__sidebar><div class="sidebar
animated fadeInDown"><div class=sidebar__content><div class=sidebar__introduction><img class=sidebar__introduction-profileimage src=/images/4ECfkGJr_400x400.jpg alt="profile picture"><div class=sidebar__introduction-title><a href=/>Computer Vision Talks</a></div><div class=sidebar__introduction-description><p>A personal blog about Computer Vision, AI, Kaggle, Open-Source and research. You will never read this in books.</p></div></div><ul class=sidebar__list><li class=sidebar__list-item><a href=https://www.linkedin.com/in/cvtalks/ target=_blank rel=noopener aria-label=Linkedin title=Linkedin><i class="fab fa-linkedin fa-2x" aria-hidden=true></i></a></li><li class=sidebar__list-item><a href=https://twitter.com/cvtalks target=_blank rel=noopener aria-label=Twitter title=Twitter><i class="fab fa-twitter fa-2x" aria-hidden=true></i></a></li><li class=sidebar__list-item><a href=https://github.com/BloodAxe target=_blank rel=noopener aria-label=GitHub title=GitHub><i class="fab fa-github fa-2x" aria-hidden=true></i></a></li><li class=sidebar__list-item><a href=mailto:ekhvedchenya@computer-vision-talks.com target=_blank rel=noopener aria-label=E-Mail title=E-Mail><i class="fas fa-envelope fa-2x" aria-hidden=true></i></a></li></ul></div><footer class="footer footer__sidebar"><ul class=footer__list><li class=footer__item>&copy;
Eugene Khvedchenya
2022</li></ul></footer><script type=text/javascript src=/js/medium-zoom.min.9c062c557275acbaba71f0c7cd4024da3e3cc825d248bc4b2130811b0965330b.js integrity="sha256-nAYsVXJ1rLq6cfDHzUAk2j48yCXSSLxLITCBGwllMws=" crossorigin=anonymous></script>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-10687369-5","auto"),ga("send","pageview"))</script><script async src=https://www.google-analytics.com/analytics.js></script></div></aside><main class=wrapper__main><header class=header><div class="animated fadeInDown"><a role=button class=navbar-burger data-target=navMenu aria-label=menu aria-expanded=false><span aria-hidden=true class=navbar-burger__line></span>
<span aria-hidden=true class=navbar-burger__line></span>
<span aria-hidden=true class=navbar-burger__line></span></a><nav class=nav><ul class=nav__list id=navMenu><li class=nav__list-item><a href=/ title>Home</a></li><li class=nav__list-item><a href=/post/ title>Posts</a></li><li class=nav__list-item><a href=/open-source title>Open-Source</a></li><li class=nav__list-item><a href=/challenges title>Wins</a></li><li class=nav__list-item><a href=/publications title>Publications</a></li></ul><ul class="nav__list nav__list--end"><li class=nav__list-item><div class=themeswitch><a title="Switch Theme"><i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></li></ul></nav></div></header><div class="post
animated fadeInDown"><div class=post__content><h1>Undocumented OpenCV</h1><ul class=post__meta><li class=post__meta-item><em class="fas fa-calendar-day post__meta-icon"></em>
<span class=post__meta-text>Fri, Jun 7, 2013</span></li><li class=post__meta-item><em class="fas fa-stopwatch post__meta-icon"></em>
<span class=post__meta-text>3-minute read</span></li></ul><p>OpenCV library is widely used by computer vision engineers across the world. It contains almost all algorithms you may want for R&D or product development. It has production-ready build farm with tests and strong community that give nice feedbacks and discover errors. But nevertheless OpenCV has some strange issues and undocummented behaviour that can surprise you as minimum and crash your app as maximum.</p><p></p><h2 id=how-to-get-diagonal-matrix-in-opencv>How to get diagonal matrix in OpenCV</h2><p>A typical parameter update computation in non-linear optimization using Levenber-Marquardt algorithm looks like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>cv</span><span class=o>::</span><span class=n>Mat</span> <span class=n>JtJ</span> <span class=o>=</span> <span class=n>J</span><span class=p>.</span><span class=n>t</span><span class=p>()</span> <span class=o>*</span> <span class=n>J</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>x</span> <span class=o>=</span> <span class=p>(</span><span class=n>JtJ</span> <span class=o>+</span> <span class=n>lambda</span> <span class=o>*</span> <span class=n>JtJ</span><span class=p>.</span><span class=n>diag</span><span class=p>()</span> <span class=p>).</span><span class=n>inv</span><span class=p>(</span><span class=n>cv</span><span class=o>::</span><span class=n>DECOMP_SVD</span><span class=p>)</span> <span class=o>*</span> <span class=p>(</span><span class=n>J</span><span class=p>.</span><span class=n>t</span><span class=p>()</span> <span class=o>*</span> <span class=n>I</span><span class=p>);</span>
</span></span></code></pre></div><p>So &lsquo;JtJ&rsquo; is a square matrix and i want to get the diagonal matrix from it. Seems correct. But hey, <strong>the member-function diag() does not return diagonal matrix</strong>! It returns a vector of diagonal elements. Really? Fine. There is a static member-function diag(), maybe it can help?</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>x</span> <span class=o>=</span> <span class=p>(</span><span class=n>JtJ</span> <span class=o>+</span> <span class=n>lambda</span> <span class=o>*</span> <span class=n>cv</span><span class=o>::</span><span class=n>Mat</span><span class=o>::</span><span class=n>diag</span><span class=p>(</span><span class=n>JtJ</span><span class=p>)).</span><span class=n>inv</span><span class=p>(</span><span class=n>cv</span><span class=o>::</span><span class=n>DECOMP_SVD</span><span class=p>)</span> <span class=o>*</span> <span class=p>(</span><span class=n>J</span><span class=p>.</span><span class=n>t</span><span class=p>()</span> <span class=o>*</span> <span class=n>I</span><span class=p>);</span>
</span></span></code></pre></div><p>Unfortunately, this is also wrong because this <strong>diag()</strong> constructs a diagonal matrix from a vector! So the correct solution to create a diagonal matrix in OpenCV is to use both diag&rsquo;s:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>cv</span><span class=o>::</span><span class=n>Mat</span> <span class=n>d</span> <span class=o>=</span> <span class=n>cv</span><span class=o>::</span><span class=n>Mat</span><span class=o>::</span><span class=n>diag</span><span class=p>(</span> <span class=n>m</span><span class=p>.</span><span class=n>diag</span><span class=p>()</span> <span class=p>);</span>
</span></span></code></pre></div><p>And the correct Lev-Mar update will have the following look:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>x</span> <span class=o>=</span> <span class=p>(</span><span class=n>JtJ</span> <span class=o>+</span> <span class=n>lambda</span> <span class=o>*</span> <span class=n>cv</span><span class=o>::</span><span class=n>Mat</span><span class=o>::</span><span class=n>diag</span><span class=p>(</span><span class=n>JtJ</span><span class=p>.</span><span class=n>diag</span><span class=p>())).</span><span class=n>inv</span><span class=p>(</span><span class=n>cv</span><span class=o>::</span><span class=n>DECOMP_SVD</span><span class=p>)</span> <span class=o>*</span> <span class=p>(</span><span class=n>J</span><span class=p>.</span><span class=n>t</span><span class=p>()</span> <span class=o>*</span> <span class=n>I</span><span class=p>);</span>
</span></span></code></pre></div><h2 id=how-to-increase-speed-of-optical-flow-klt-in-opencv>How to increase speed of optical flow (KLT) in OpenCV</h2><p>If you were using OpenCV version 1.x you should remeber there was a cvCalcOpticalFlowPyrLK function that allowed to pass image pyramids. The motivation to use precomputed image pyramids is performance gain. When you continuously tracking video frames you can save time by storing built pyramid from current frame.</p><p>The C++ API provide the following function prototype for this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>//! computes sparse optical flow using multi-scale Lucas-Kanade algorithm
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>CV_EXPORTS_W</span> <span class=kt>void</span> <span class=nf>calcOpticalFlowPyrLK</span><span class=p>(</span> <span class=n>InputArray</span> <span class=n>prevImg</span><span class=p>,</span> <span class=n>InputArray</span> <span class=n>nextImg</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                        <span class=n>InputArray</span> <span class=n>prevPts</span><span class=p>,</span> <span class=n>InputOutputArray</span> <span class=n>nextPts</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                        <span class=n>OutputArray</span> <span class=n>status</span><span class=p>,</span> <span class=n>OutputArray</span> <span class=n>err</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                        <span class=n>Size</span> <span class=n>winSize</span> <span class=o>=</span> <span class=n>Size</span><span class=p>(</span><span class=mi>21</span><span class=p>,</span><span class=mi>21</span><span class=p>),</span> <span class=kt>int</span> <span class=n>maxLevel</span> <span class=o>=</span> <span class=mi>3</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                        <span class=n>TermCriteria</span> <span class=n>criteria</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                        <span class=kt>int</span> <span class=n>flags</span><span class=p>,</span> <span class=kt>double</span> <span class=n>minEigThreshold</span><span class=p>);</span>
</span></span></code></pre></div><p>From the function declaration and <a href="http://docs.opencv.org/modules/video/doc/motion_analysis_and_object_tracking.html&usg=AFQjCNGCeanEXmqKq5DU7dpbp1m2xo0lPA">documentation</a> it&rsquo;s visible that <em>prevImg</em> and <em>nextImg</em> are arguments for previous and next image buffers. Does it mean that you can&rsquo;t use prebuilt pyramids? No! This is not documented, but you can precompute image pyramid using <strong>cv::buildOpticalFlowPyramid</strong> like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>cv</span><span class=o>::</span><span class=n>mat</span><span class=o>&gt;</span> <span class=n>prevPyr</span><span class=p>,</span> <span class=n>nextPyr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// prevPyr assumed to be already initialized 
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>cv</span><span class=o>::</span><span class=n>buildOpticalFlowPyramid</span><span class=p>(</span><span class=n>nextFrame</span><span class=p>,</span> <span class=n>nextPyr</span><span class=p>,</span> <span class=n>winSize</span><span class=p>,</span> <span class=n>maxLevel</span><span class=p>,</span> <span class=nb>true</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>cv</span><span class=o>::</span><span class=n>calcOpticalFlowPyrLK</span><span class=p>(</span><span class=n>prevPyr</span><span class=p>,</span> <span class=n>nextPyr</span><span class=p>,</span> <span class=n>prevPts</span><span class=p>,</span> <span class=n>nextPts</span><span class=p>,</span> <span class=n>status</span><span class=p>,</span> <span class=n>err</span><span class=p>,</span> <span class=n>winSize</span><span class=p>,</span> <span class=n>maxLevel</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>prevPyr</span><span class=p>.</span><span class=n>swap</span><span class=p>(</span><span class=n>nextPyr</span><span class=p>);</span>
</span></span></code></pre></div><p>On my PC this trick increased performance of KLT almost twice!</p><h2 id=cvfindhomography-can-return-empty-result>cv::findHomography can return empty result</h2><p>The documentation of cv::findHomography does not state it, but return value of cv::findHomography was always 3x3 matrix of CV_64FC1 type. Starting from approximately 2.4.5 release <strong>cv::findHomography can return empty matrix in some cases</strong>. This seems happen only when cv::RANSAC flag is passed. This <a href=http://code.opencv.org/issues/3057>issue</a> has been reported but i suggest to check the computed homography before using it anywhere:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>cv</span><span class=o>::</span><span class=n>Mat</span> <span class=n>h</span> <span class=o>=</span> <span class=n>cv</span><span class=o>::</span><span class=n>findHomography</span><span class=p>(....)</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>h</span><span class=p>.</span><span class=n>empty</span><span class=p>())</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Use it
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><h2 id=summary>Summary</h2><p>That&rsquo;s all for now. I hope you enjoy working with OpenCV like i do. This post will be updated with new &ldquo;easter-eggs&rdquo;. Feel free to share you own discoveries.</p></div><div class=post__footer><span><a class=tag href=/tags/opencv/>opencv</a></span></div><div id=comment><h2>comments</h2><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//cvtalks.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></div></main></div><footer class="footer footer__base"><ul class=footer__list><li class=footer__item>&copy;
Eugene Khvedchenya
2022</li></ul></footer><script type=text/javascript src=/js/medium-zoom.min.9c062c557275acbaba71f0c7cd4024da3e3cc825d248bc4b2130811b0965330b.js integrity="sha256-nAYsVXJ1rLq6cfDHzUAk2j48yCXSSLxLITCBGwllMws=" crossorigin=anonymous></script>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-10687369-5","auto"),ga("send","pageview"))</script><script async src=https://www.google-analytics.com/analytics.js></script></body></html>