<!doctype html><html dir=ltr lang=en data-theme class=html><head><title>Eugene Khvedchenya
|
Integration of KAZE 1.6 in OpenCV</title><meta charset=utf-8><meta name=generator content="Hugo 0.98.0"><meta name=viewport content="width=device-width,initial-scale=1,viewport-fit=cover"><meta name=author content="Eugene Khvedchenya"><meta name=description content="A personal blog about Computer Vision, AI, Kaggle, Open-Source and research. You will never read this in books."><link rel=stylesheet href=/scss/main.min.b2e0cb07595e3519ab1193bb421914e06c0e26b0cc561fef23b3c6131d4d2ffa.css integrity="sha256-suDLB1leNRmrEZO7QhkU4GwOJrDMVh/vI7PGEx1NL/o=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/css/markupHighlight.min.31b0a1f317f55c529a460897848c97436bb138b19c399b37de70d463a8bf6ed5.css integrity="sha256-MbCh8xf1XFKaRgiXhIyXQ2uxOLGcOZs33nDUY6i/btU=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/fontawesome/css/fontawesome.min.7d272de35b410fb165377550cdf9c4d3a80fbbcc961e111914e4d5c0eaf5729f.css integrity="sha256-fSct41tBD7FlN3VQzfnE06gPu8yWHhEZFOTVwOr1cp8=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/fontawesome/css/solid.min.55d8333481b07a08e07cf6f37319753a2b47e99f4c395394c5747b48b495aa9b.css integrity="sha256-VdgzNIGwegjgfPbzcxl1OitH6Z9MOVOUxXR7SLSVqps=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/fontawesome/css/regular.min.a7448d02590b43449364b6b5922ed9af5410abb4de4238412a830316dedb850b.css integrity="sha256-p0SNAlkLQ0STZLa1ki7Zr1QQq7TeQjhBKoMDFt7bhQs=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/fontawesome/css/brands.min.9ed75a5d670c953fe4df935937674b4646f92674367e9e66eb995bb04e821647.css integrity="sha256-ntdaXWcMlT/k35NZN2dLRkb5JnQ2fp5m65lbsE6CFkc=" crossorigin=anonymous type=text/css><link rel="shortcut icon" href=/favicon.ico type=image/x-icon><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=canonical href=https://computer-vision-talks.com/post/kaze-1.6-in-opencv/><script type=text/javascript src=/js/anatole-header.min.f9132794301a01ff16550ed66763482bd848f62243d278f5e550229a158bfd32.js integrity="sha256-+RMnlDAaAf8WVQ7WZ2NIK9hI9iJD0nj15VAimhWL/TI=" crossorigin=anonymous></script>
<script type=text/javascript src=/js/anatole-theme-switcher.min.560a26330d27ff44a44e83b53cd07a95d4230a65930d31c5c76a8d481e5b35bf.js integrity="sha256-VgomMw0n/0SkToO1PNB6ldQjCmWTDTHFx2qNSB5bNb8=" crossorigin=anonymous></script><meta name=twitter:card content="summary"><meta name=twitter:title content="Integration of KAZE 1.6 in OpenCV"><meta name=twitter:description content="A new version of KAZE and AKAZE features is a good candidate to become a part of OpenCV. So i decided to update KAZE port i made a while ago with a new version of these features and finally make a pull request to make it a part of OpenCV.
The OpenCV has accepted my pull-request and merged KAZE port into master branch of the OpenCV library. KAZE and AKAZE features will become available in OpenCV 3."><meta property="og:title" content="Integration of KAZE 1.6 in OpenCV"><meta property="og:description" content="A new version of KAZE and AKAZE features is a good candidate to become a part of OpenCV. So i decided to update KAZE port i made a while ago with a new version of these features and finally make a pull request to make it a part of OpenCV.
The OpenCV has accepted my pull-request and merged KAZE port into master branch of the OpenCV library. KAZE and AKAZE features will become available in OpenCV 3."><meta property="og:type" content="article"><meta property="og:url" content="https://computer-vision-talks.com/post/kaze-1.6-in-opencv/"><meta property="article:section" content="post"><meta property="article:published_time" content="2014-04-03T00:00:00+00:00"><meta property="article:modified_time" content="2014-04-03T00:00:00+00:00"><meta property="og:site_name" content="Computer Vision Talks"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","articleSection":"post","name":"Integration of KAZE 1.6 in OpenCV","headline":"Integration of KAZE 1.6 in OpenCV","alternativeHeadline":"","description":"
      
        A new version of KAZE and AKAZE features is a good candidate to become a part of OpenCV. So i decided to update KAZE port i made a while ago with a new version of these features and finally make a pull request to make it a part of OpenCV.\nThe OpenCV has accepted my pull-request and merged KAZE port into master branch of the OpenCV library. KAZE and AKAZE features will become available in OpenCV 3.


      


    ","inLanguage":"en-us","isFamilyFriendly":"true","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/computer-vision-talks.com\/post\/kaze-1.6-in-opencv\/"},"author":{"@type":"Person","name":"Eugene Khvedchenya"},"creator":{"@type":"Person","name":"Eugene Khvedchenya"},"accountablePerson":{"@type":"Person","name":"Eugene Khvedchenya"},"copyrightHolder":{"@type":"Person","name":"Eugene Khvedchenya"},"copyrightYear":"2014","dateCreated":"2014-04-03T00:00:00.00Z","datePublished":"2014-04-03T00:00:00.00Z","dateModified":"2014-04-03T00:00:00.00Z","publisher":{"@type":"Organization","name":"Eugene Khvedchenya","url":"https://computer-vision-talks.com/","logo":{"@type":"ImageObject","url":"https:\/\/computer-vision-talks.com\/favicon-32x32.png","width":"32","height":"32"}},"image":[],"url":"https:\/\/computer-vision-talks.com\/post\/kaze-1.6-in-opencv\/","wordCount":"1592","genre":[],"keywords":["opencv","algorithms"]}</script></head><body class="body theme--light"><div class=wrapper><aside class=wrapper__sidebar><div class="sidebar
animated fadeInDown"><div class=sidebar__content><div class=sidebar__introduction><img class=sidebar__introduction-profileimage src=/images/4ECfkGJr_400x400.jpg alt="profile picture"><div class=sidebar__introduction-title><a href=/>Computer Vision Talks</a></div><div class=sidebar__introduction-description><p>A personal blog about Computer Vision, AI, Kaggle, Open-Source and research. You will never read this in books.</p></div></div><ul class=sidebar__list><li class=sidebar__list-item><a href=https://www.linkedin.com/in/cvtalks/ target=_blank rel=noopener aria-label=Linkedin title=Linkedin><i class="fab fa-linkedin fa-2x" aria-hidden=true></i></a></li><li class=sidebar__list-item><a href=https://twitter.com/cvtalks target=_blank rel=noopener aria-label=Twitter title=Twitter><i class="fab fa-twitter fa-2x" aria-hidden=true></i></a></li><li class=sidebar__list-item><a href=https://github.com/BloodAxe target=_blank rel=noopener aria-label=GitHub title=GitHub><i class="fab fa-github fa-2x" aria-hidden=true></i></a></li><li class=sidebar__list-item><a href=mailto:ekhvedchenya@computer-vision-talks.com target=_blank rel=noopener aria-label=E-Mail title=E-Mail><i class="fas fa-envelope fa-2x" aria-hidden=true></i></a></li></ul></div><footer class="footer footer__sidebar"><ul class=footer__list><li class=footer__item>&copy;
Eugene Khvedchenya
2022</li></ul></footer><script type=text/javascript src=/js/medium-zoom.min.9c062c557275acbaba71f0c7cd4024da3e3cc825d248bc4b2130811b0965330b.js integrity="sha256-nAYsVXJ1rLq6cfDHzUAk2j48yCXSSLxLITCBGwllMws=" crossorigin=anonymous></script>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-10687369-5","auto"),ga("send","pageview"))</script><script async src=https://www.google-analytics.com/analytics.js></script></div></aside><main class=wrapper__main><header class=header><div class="animated fadeInDown"><a role=button class=navbar-burger data-target=navMenu aria-label=menu aria-expanded=false><span aria-hidden=true class=navbar-burger__line></span>
<span aria-hidden=true class=navbar-burger__line></span>
<span aria-hidden=true class=navbar-burger__line></span></a><nav class=nav><ul class=nav__list id=navMenu><li class=nav__list-item><a href=/ title>Home</a></li><li class=nav__list-item><a href=/post/ title>Posts</a></li><li class=nav__list-item><a href=/open-source title>Open-Source</a></li><li class=nav__list-item><a href=/challenges title>Wins</a></li><li class=nav__list-item><a href=/publications title>Publications</a></li></ul><ul class="nav__list nav__list--end"><li class=nav__list-item><div class=themeswitch><a title="Switch Theme"><i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></li></ul></nav></div></header><div class="post
animated fadeInDown"><div class=post__content><h1>Integration of KAZE 1.6 in OpenCV</h1><ul class=post__meta><li class=post__meta-item><em class="fas fa-calendar-day post__meta-icon"></em>
<span class=post__meta-text>Thu, Apr 3, 2014</span></li><li class=post__meta-item><em class="fas fa-stopwatch post__meta-icon"></em>
<span class=post__meta-text>8-minute read</span></li></ul><p>A new version of KAZE and AKAZE features is a good candidate to become a part of OpenCV.
So i decided to update KAZE port i made a while ago with a new version of these features
and finally make a pull request to make it a part of OpenCV.</p><p>The OpenCV has accepted my pull-request and merged KAZE port into master branch of the OpenCV library. KAZE and AKAZE features will become available in OpenCV 3.0. Of course, you can grab development branch and build it from scratch to access it now.</p><p><strong><a href=#results>TL;DR; Scroll down to estimation charts</a></strong>.</p><h1 id=integration-roadmap>Integration roadmap</h1><p>I&rsquo;m going to keep KAZE sources intact if possible to simplify their further support.
Original KAZE and AKAZE implementations will be placed in <code>kaze/</code> and <code>akaze/</code> folders under <code>features2/</code> module and what we want is to write a facade-wrappers for these algorithms.</p><p>To integrate KAZE featues we need to adopt sources code to OpenCV coding guidelines, make consistent with headers include system,
integrate into build system, implement wrapped from KAZE to Features2D API and add unit tests. This will be split into three steps:</p><ul><li>Adopt KAZE and AKAZE sources (Remove unused functions, fix includes, macros)</li><li>Implement Features2D wrappers and expose properties for runtime configuration of KAZE.</li><li>Add unit tests and remove duplicate functions that are already exists in OpenCV.</li><li>Replace OpenMP with cv::parallel_for_</li></ul><h2 id=changes-in-kaze-sources>Changes in KAZE sources</h2><p>First, we need to adopt existing sources.</p><h3 id=step-1--update-opencv-includes>Step 1 -Update OpenCV includes</h3><p>Since we&rsquo;re making KAZE a part of the library, it&rsquo;s impossible to reference OpenCV types using standard.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;opencv2/opencv.h&#34;</span><span class=cp>
</span></span></span></code></pre></div><p>Instead one may want to use precomp.hpp header like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;precomp.hpp&#34;</span><span class=cp>
</span></span></span></code></pre></div><h3 id=step-2---cleaning-up-the-code>Step 2 - Cleaning up the code</h3><p>p There is a C-style assert(cond) macro that I will replace with CV_Assert for convinience.</p><h4 id=dump-of-kaze-internal-structures>Dump of KAZE internal structures</h4><p>KAZE and AKAZE algorithm can &lsquo;dump&rsquo; internal buffers to disk using imwrite function.
But features2d module can not be available and i assume the goal of this feature was to simplify debugging of KAZE features.
Since we may expect it is mature enough, we will remove these functions (<code>Save_Scale_Space</code>, <code>Save_Detector_Responses</code>, <code>Save_Flow_Responses</code>, <code>Save_Nonlinear_Scale_Space</code>) from sources.</p><h4 id=fixing-the-pi-constant>Fixing the PI constant</h4><p>KAZE uses <code>M_PI</code> symbol to represent Pi number. We will use <code>CV_PI</code> replacement instead.</p><h4 id=cleanup-utilscpp>Cleanup utils.cpp</h4><p>Helper file utils.cpp contains auxilar functions that is not used by KAZE directly but rather used for precision esitmation.
We don&rsquo;t need these functions in OpenCV packages. So we say goodbye to following functions:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>draw_keypoints</span><span class=p>(</span><span class=n>cv</span><span class=o>::</span><span class=n>Mat</span><span class=o>&amp;</span> <span class=n>img</span><span class=p>,</span> <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>cv</span><span class=o>::</span><span class=n>KeyPoint</span><span class=o>&gt;&amp;</span> <span class=n>kpts</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>save_keypoints</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&amp;</span> <span class=n>outFile</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                   <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>cv</span><span class=o>::</span><span class=n>KeyPoint</span><span class=o>&gt;&amp;</span> <span class=n>kpts</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                   <span class=k>const</span> <span class=n>cv</span><span class=o>::</span><span class=n>Mat</span><span class=o>&amp;</span> <span class=n>desc</span><span class=p>,</span> <span class=kt>bool</span> <span class=n>save_desc</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>matches2points_nndr</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>cv</span><span class=o>::</span><span class=n>KeyPoint</span><span class=o>&gt;&amp;</span> <span class=n>train</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                         <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>cv</span><span class=o>::</span><span class=n>KeyPoint</span><span class=o>&gt;&amp;</span> <span class=n>query</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                         <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>cv</span><span class=o>::</span><span class=n>DMatch</span><span class=o>&gt;</span> <span class=o>&gt;&amp;</span> <span class=n>matches</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                         <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>cv</span><span class=o>::</span><span class=n>Point2f</span><span class=o>&gt;&amp;</span> <span class=n>pmatches</span><span class=p>,</span> <span class=kt>float</span> <span class=n>nndr</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>compute_inliers_ransac</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>cv</span><span class=o>::</span><span class=n>Point2f</span><span class=o>&gt;&amp;</span> <span class=n>matches</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                            <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>cv</span><span class=o>::</span><span class=n>Point2f</span><span class=o>&gt;&amp;</span> <span class=n>inliers</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                            <span class=kt>float</span> <span class=n>error</span><span class=p>,</span> <span class=kt>bool</span> <span class=n>use_fund</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>compute_inliers_homography</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>cv</span><span class=o>::</span><span class=n>Point2f</span><span class=o>&gt;&amp;</span> <span class=n>matches</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>cv</span><span class=o>::</span><span class=n>Point2f</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>inliers</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                <span class=k>const</span> <span class=n>cv</span><span class=o>::</span><span class=n>Mat</span><span class=o>&amp;</span><span class=n>H</span><span class=p>,</span> <span class=kt>float</span> <span class=n>min_error</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>draw_inliers</span><span class=p>(</span><span class=k>const</span> <span class=n>cv</span><span class=o>::</span><span class=n>Mat</span><span class=o>&amp;</span> <span class=n>img1</span><span class=p>,</span> <span class=k>const</span> <span class=n>cv</span><span class=o>::</span><span class=n>Mat</span><span class=o>&amp;</span> <span class=n>img2</span><span class=p>,</span> <span class=n>cv</span><span class=o>::</span><span class=n>Mat</span><span class=o>&amp;</span> <span class=n>img_com</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                  <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>cv</span><span class=o>::</span><span class=n>Point2f</span><span class=o>&gt;&amp;</span> <span class=n>ptpairs</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>draw_inliers</span><span class=p>(</span><span class=k>const</span> <span class=n>cv</span><span class=o>::</span><span class=n>Mat</span><span class=o>&amp;</span> <span class=n>img1</span><span class=p>,</span> <span class=k>const</span> <span class=n>cv</span><span class=o>::</span><span class=n>Mat</span><span class=o>&amp;</span> <span class=n>img2</span><span class=p>,</span> <span class=n>cv</span><span class=o>::</span><span class=n>Mat</span><span class=o>&amp;</span> <span class=n>img_com</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                  <span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>cv</span><span class=o>::</span><span class=n>Point2f</span><span class=o>&gt;&amp;</span> <span class=n>ptpairs</span><span class=p>,</span> <span class=kt>int</span> <span class=n>color</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>read_homography</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&amp;</span> <span class=n>hFile</span><span class=p>,</span> <span class=n>cv</span><span class=o>::</span><span class=n>Mat</span><span class=o>&amp;</span> <span class=n>H1toN</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>show_input_options_help</span><span class=p>(</span><span class=kt>int</span> <span class=n>example</span><span class=p>);</span>
</span></span></code></pre></div><h3 id=step-3---fix-constant-expression-bug-in-compute_derivative_kernels>Step 3 - Fix constant expression bug in compute_derivative_kernels</h3><p>This is very similar to a bug - a static array get initialized with ksize that is not compile-time defined.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>compute_derivative_kernels</span><span class=p>(</span><span class=n>cv</span><span class=o>::</span><span class=n>OutputArray</span> <span class=n>_kx</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>                                <span class=n>cv</span><span class=o>::</span><span class=n>OutputArray</span> <span class=n>_ky</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                <span class=kt>int</span> <span class=n>dx</span><span class=p>,</span> <span class=kt>int</span> <span class=n>dy</span><span class=p>,</span> <span class=kt>int</span> <span class=n>scale</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>ksize</span> <span class=o>=</span> <span class=mi>3</span> <span class=o>+</span> <span class=mi>2</span><span class=o>*</span><span class=p>(</span><span class=n>scale</span><span class=o>-</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=kt>float</span> <span class=n>kerI</span><span class=p>[</span><span class=n>ksize</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>We can quickly fix this issue with std::vector:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>compute_derivative_kernels</span><span class=p>(</span><span class=n>cv</span><span class=o>::</span><span class=n>OutputArray</span> <span class=n>_kx</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>                                <span class=n>cv</span><span class=o>::</span><span class=n>OutputArray</span> <span class=n>_ky</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                <span class=kt>int</span> <span class=n>dx</span><span class=p>,</span> <span class=kt>int</span> <span class=n>dy</span><span class=p>,</span> <span class=kt>int</span> <span class=n>scale</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>ksize</span> <span class=o>=</span> <span class=mi>3</span> <span class=o>+</span> <span class=mi>2</span><span class=o>*</span><span class=p>(</span><span class=n>scale</span><span class=o>-</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>float</span><span class=o>&gt;</span> <span class=n>kerI</span><span class=p>(</span><span class=n>ksize</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=step-5---wrapping-kaze-for-opencv>Step 5 - Wrapping KAZE for OpenCV</h3><p>OpenCV provides three base types for extending features2d API:</p><ul><li><code>cv::FeaturesDetector</code></li><li><code>cv::DescriptorExtractor</code></li><li><code>cv::Feature2D</code></li></ul><p>Since KAZE features provides both detector and descriptor extractor features, we will derive
our class from <code>cv::Feature2D</code>.
First, we should implement helper functions to indicate depth and size of feature descriptor and matcher type:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// returns the descriptor size in bytes
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>KAZE</span><span class=o>::</span><span class=n>descriptorSize</span><span class=p>()</span> <span class=k>const</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>extended</span> <span class=o>?</span> <span class=mi>128</span> <span class=o>:</span> <span class=mi>64</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// returns the descriptor type
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>KAZE</span><span class=o>::</span><span class=n>descriptorType</span><span class=p>()</span> <span class=k>const</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>CV_32F</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// returns the default norm type
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>KAZE</span><span class=o>::</span><span class=n>defaultNorm</span><span class=p>()</span> <span class=k>const</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>NORM_L2</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>In order to make OpenCV happy we need to implement three virtual functions from Feature2D: <code>detectImpl</code>, <code>computeImpl</code>
and <code>operator()</code> also known as <strong>detectAndCompute</strong>.</p><h3 id=step-6---detection-of-kaze-keypoints>Step 6 - Detection of KAZE keypoints:</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=n>KAZE</span><span class=o>::</span><span class=n>detectImpl</span><span class=p>(</span><span class=n>InputArray</span> <span class=n>image</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>KeyPoint</span><span class=o>&gt;&amp;</span> <span class=n>keypoints</span><span class=p>,</span> <span class=n>InputArray</span> <span class=n>mask</span><span class=p>)</span> <span class=k>const</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Mat</span> <span class=n>img</span> <span class=o>=</span> <span class=n>image</span><span class=p>.</span><span class=n>getMat</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>img</span><span class=p>.</span><span class=n>type</span><span class=p>()</span> <span class=o>!=</span> <span class=n>CV_8UC1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>cvtColor</span><span class=p>(</span><span class=n>image</span><span class=p>,</span> <span class=n>img</span><span class=p>,</span> <span class=n>COLOR_BGR2GRAY</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>Mat</span> <span class=n>img1_32</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>img</span><span class=p>.</span><span class=n>convertTo</span><span class=p>(</span><span class=n>img1_32</span><span class=p>,</span> <span class=n>CV_32F</span><span class=p>,</span> <span class=mf>1.0</span> <span class=o>/</span> <span class=mf>255.0</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>KAZEOptions</span> <span class=n>options</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>options</span><span class=p>.</span><span class=n>img_width</span> <span class=o>=</span> <span class=n>img</span><span class=p>.</span><span class=n>cols</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>options</span><span class=p>.</span><span class=n>img_height</span> <span class=o>=</span> <span class=n>img</span><span class=p>.</span><span class=n>rows</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>options</span><span class=p>.</span><span class=n>extended</span> <span class=o>=</span> <span class=n>extended</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>KAZEFeatures</span> <span class=nf>impl</span><span class=p>(</span><span class=n>options</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>impl</span><span class=p>.</span><span class=n>Create_Nonlinear_Scale_Space</span><span class=p>(</span><span class=n>img1_32</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>impl</span><span class=p>.</span><span class=n>Feature_Detection</span><span class=p>(</span><span class=n>keypoints</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>mask</span><span class=p>.</span><span class=n>empty</span><span class=p>())</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>cv</span><span class=o>::</span><span class=n>KeyPointsFilter</span><span class=o>::</span><span class=n>runByPixelsMask</span><span class=p>(</span><span class=n>keypoints</span><span class=p>,</span> <span class=n>mask</span><span class=p>.</span><span class=n>getMat</span><span class=p>());</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Please note that we conver input image to grayscale normalized to [0;1] floating-point image.
This is a requirement of KAZE algorithm.</p><h3 id=step-7---extraction-of-kaze-descriptors>Step 7 - Extraction of KAZE descriptors:</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=n>KAZE</span><span class=o>::</span><span class=n>computeImpl</span><span class=p>(</span><span class=n>InputArray</span> <span class=n>image</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>                       <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>KeyPoint</span><span class=o>&gt;&amp;</span> <span class=n>keypoints</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>                       <span class=n>OutputArray</span> <span class=n>descriptors</span><span class=p>)</span> <span class=k>const</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>cv</span><span class=o>::</span><span class=n>Mat</span> <span class=n>img</span> <span class=o>=</span> <span class=n>image</span><span class=p>.</span><span class=n>getMat</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>img</span><span class=p>.</span><span class=n>type</span><span class=p>()</span> <span class=o>!=</span> <span class=n>CV_8UC1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>cvtColor</span><span class=p>(</span><span class=n>image</span><span class=p>,</span> <span class=n>img</span><span class=p>,</span> <span class=n>COLOR_BGR2GRAY</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>Mat</span> <span class=n>img1_32</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>img</span><span class=p>.</span><span class=n>convertTo</span><span class=p>(</span><span class=n>img1_32</span><span class=p>,</span> <span class=n>CV_32F</span><span class=p>,</span> <span class=mf>1.0</span> <span class=o>/</span> <span class=mf>255.0</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>cv</span><span class=o>::</span><span class=n>Mat</span><span class=o>&amp;</span> <span class=n>desc</span> <span class=o>=</span> <span class=n>descriptors</span><span class=p>.</span><span class=n>getMatRef</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>KAZEOptions</span> <span class=n>options</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>options</span><span class=p>.</span><span class=n>img_width</span> <span class=o>=</span> <span class=n>img</span><span class=p>.</span><span class=n>cols</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>options</span><span class=p>.</span><span class=n>img_height</span> <span class=o>=</span> <span class=n>img</span><span class=p>.</span><span class=n>rows</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>options</span><span class=p>.</span><span class=n>extended</span> <span class=o>=</span> <span class=n>extended</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>KAZEFeatures</span> <span class=nf>impl</span><span class=p>(</span><span class=n>options</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>impl</span><span class=p>.</span><span class=n>Create_Nonlinear_Scale_Space</span><span class=p>(</span><span class=n>img1_32</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>impl</span><span class=p>.</span><span class=n>Feature_Description</span><span class=p>(</span><span class=n>keypoints</span><span class=p>,</span> <span class=n>desc</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>CV_Assert</span><span class=p>(</span><span class=o>!</span><span class=n>desc</span><span class=p>.</span><span class=n>rows</span> <span class=o>||</span> <span class=n>desc</span><span class=p>.</span><span class=n>cols</span> <span class=o>==</span> <span class=n>descriptorSize</span><span class=p>()</span> <span class=o>&amp;&amp;</span> 
</span></span><span class=line><span class=cl>              <span class=s>&#34;Descriptor size does not match expected&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>CV_Assert</span><span class=p>(</span><span class=o>!</span><span class=n>desc</span><span class=p>.</span><span class=n>rows</span> <span class=o>||</span> <span class=p>(</span><span class=n>desc</span><span class=p>.</span><span class=n>type</span><span class=p>()</span> <span class=o>&amp;</span> <span class=n>descriptorType</span><span class=p>())</span> <span class=o>&amp;&amp;</span> 
</span></span><span class=line><span class=cl>              <span class=s>&#34;Descriptor type does not match expected&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Two asserts at the end of the function to ensure that KAZE returns consistent with <code>descriptorType()</code> and <code>descriptorSize()</code> results.</p><h3 id=step-8---detection-and-extraction-at-single-call>Step 8 - Detection and extraction at single call:</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=n>KAZE</span><span class=o>::</span><span class=k>operator</span><span class=p>()(</span><span class=n>InputArray</span> <span class=n>image</span><span class=p>,</span> <span class=n>InputArray</span> <span class=n>mask</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>KeyPoint</span><span class=o>&gt;&amp;</span> <span class=n>keypoints</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>OutputArray</span> <span class=n>descriptors</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=n>useProvidedKeypoints</span><span class=p>)</span> <span class=k>const</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>cv</span><span class=o>::</span><span class=n>Mat</span> <span class=n>img</span> <span class=o>=</span> <span class=n>image</span><span class=p>.</span><span class=n>getMat</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>img</span><span class=p>.</span><span class=n>type</span><span class=p>()</span> <span class=o>!=</span> <span class=n>CV_8UC1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>cvtColor</span><span class=p>(</span><span class=n>image</span><span class=p>,</span> <span class=n>img</span><span class=p>,</span> <span class=n>COLOR_BGR2GRAY</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>Mat</span> <span class=n>img1_32</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>img</span><span class=p>.</span><span class=n>convertTo</span><span class=p>(</span><span class=n>img1_32</span><span class=p>,</span> <span class=n>CV_32F</span><span class=p>,</span> <span class=mf>1.0</span> <span class=o>/</span> <span class=mf>255.0</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>cv</span><span class=o>::</span><span class=n>Mat</span><span class=o>&amp;</span> <span class=n>desc</span> <span class=o>=</span> <span class=n>descriptors</span><span class=p>.</span><span class=n>getMatRef</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>KAZEOptions</span> <span class=n>options</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>options</span><span class=p>.</span><span class=n>img_width</span> <span class=o>=</span> <span class=n>img</span><span class=p>.</span><span class=n>cols</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>options</span><span class=p>.</span><span class=n>img_height</span> <span class=o>=</span> <span class=n>img</span><span class=p>.</span><span class=n>rows</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>options</span><span class=p>.</span><span class=n>extended</span> <span class=o>=</span> <span class=n>extended</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>KAZEFeatures</span> <span class=nf>impl</span><span class=p>(</span><span class=n>options</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>impl</span><span class=p>.</span><span class=n>Create_Nonlinear_Scale_Space</span><span class=p>(</span><span class=n>img1_32</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>useProvidedKeypoints</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>impl</span><span class=p>.</span><span class=n>Feature_Detection</span><span class=p>(</span><span class=n>keypoints</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>mask</span><span class=p>.</span><span class=n>empty</span><span class=p>())</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>cv</span><span class=o>::</span><span class=n>KeyPointsFilter</span><span class=o>::</span><span class=n>runByPixelsMask</span><span class=p>(</span><span class=n>keypoints</span><span class=p>,</span> <span class=n>mask</span><span class=p>.</span><span class=n>getMat</span><span class=p>());</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>impl</span><span class=p>.</span><span class=n>Feature_Description</span><span class=p>(</span><span class=n>keypoints</span><span class=p>,</span> <span class=n>desc</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>CV_Assert</span><span class=p>(</span><span class=o>!</span><span class=n>desc</span><span class=p>.</span><span class=n>rows</span> <span class=o>||</span> <span class=n>desc</span><span class=p>.</span><span class=n>cols</span> <span class=o>==</span> <span class=n>descriptorSize</span><span class=p>()</span> <span class=o>&amp;&amp;</span> 
</span></span><span class=line><span class=cl>              <span class=s>&#34;Descriptor size does not match expected&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>CV_Assert</span><span class=p>(</span><span class=o>!</span><span class=n>desc</span><span class=p>.</span><span class=n>rows</span> <span class=o>||</span> <span class=p>(</span><span class=n>desc</span><span class=p>.</span><span class=n>type</span><span class=p>()</span> <span class=o>&amp;</span> <span class=n>descriptorType</span><span class=p>())</span> <span class=o>&amp;&amp;</span> 
</span></span><span class=line><span class=cl>              <span class=s>&#34;Descriptor type does not match expected&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=step-9---algorithm-configuration>Step 9 - Algorithm configuration</h3><p>OpenCV provides an option to create and configure algorithm in runtime by it&rsquo;s name. This is done by using special CV_INIT_ALGORITHM marco, that initialize all OpenCV algorithms during startup. Using this macro we register new KAZE and AKAZE algorithms under Feature2D module and expose additional properties that user can change in runtime:</p><p><strong>features2d_init.cpp</strong>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>CV_INIT_ALGORITHM</span><span class=p>(</span><span class=n>KAZE</span><span class=p>,</span> <span class=s>&#34;Feature2D.KAZE&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                  <span class=n>obj</span><span class=p>.</span><span class=n>info</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>addParam</span><span class=p>(</span><span class=n>obj</span><span class=p>,</span> <span class=s>&#34;extended&#34;</span><span class=p>,</span> <span class=n>obj</span><span class=p>.</span><span class=n>extended</span><span class=p>))</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl><span class=n>CV_INIT_ALGORITHM</span><span class=p>(</span><span class=n>AKAZE</span><span class=p>,</span> <span class=s>&#34;Feature2D.AKAZE&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                  <span class=n>obj</span><span class=p>.</span><span class=n>info</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>addParam</span><span class=p>(</span><span class=n>obj</span><span class=p>,</span> <span class=s>&#34;descriptor_channels&#34;</span><span class=p>,</span> <span class=n>obj</span><span class=p>.</span><span class=n>descriptor_channels</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                  <span class=n>obj</span><span class=p>.</span><span class=n>info</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>addParam</span><span class=p>(</span><span class=n>obj</span><span class=p>,</span> <span class=s>&#34;descriptor&#34;</span><span class=p>,</span> <span class=n>obj</span><span class=p>.</span><span class=n>descriptor</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                  <span class=n>obj</span><span class=p>.</span><span class=n>info</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>addParam</span><span class=p>(</span><span class=n>obj</span><span class=p>,</span> <span class=s>&#34;descriptor_size&#34;</span><span class=p>,</span> <span class=n>obj</span><span class=p>.</span><span class=n>descriptor_size</span><span class=p>))</span>
</span></span></code></pre></div><p>Please note, that KAZE and AKAZE has much more properties. They (and documentation for them) will be added later.</p><h3 id=step-10---unit-tests>Step 10 - Unit tests</h3><p>There is a nice feature detectors and descriptors unit testing system in OpenCV. Using it is very simple, but it performs many sanity checks and validates both parths of Features2D API.</p><p><strong>test_keypoints.cpp</strong>:</p><p>All we need to do is to add a new unit test suites:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>TEST</span><span class=p>(</span><span class=n>Features2d_Detector_Keypoints_KAZE</span><span class=p>,</span> <span class=n>validation</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>CV_FeatureDetectorKeypointsTest</span> <span class=nf>test</span><span class=p>(</span><span class=n>Algorithm</span><span class=o>::</span><span class=n>create</span><span class=o>&lt;</span><span class=n>FeatureDetector</span><span class=o>&gt;</span><span class=p>(</span><span class=s>&#34;Feature2D.KAZE&#34;</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=n>test</span><span class=p>.</span><span class=n>safe_run</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>TEST</span><span class=p>(</span><span class=n>Features2d_Detector_Keypoints_AKAZE</span><span class=p>,</span> <span class=n>validation</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>CV_FeatureDetectorKeypointsTest</span> <span class=nf>test</span><span class=p>(</span><span class=n>Algorithm</span><span class=o>::</span><span class=n>create</span><span class=o>&lt;</span><span class=n>FeatureDetector</span><span class=o>&gt;</span><span class=p>(</span><span class=s>&#34;Feature2D.AKAZE&#34;</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=n>test</span><span class=p>.</span><span class=n>safe_run</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>In addition to simple checks that our implementation does some job, there are more sophisticaed tests to verify rotation and scale invariance of the computed features.</p><p><strong>test_rotation_and_scale_invariance.cpp</strong>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>TEST</span><span class=p>(</span><span class=n>Features2d_ScaleInvariance_Detector_KAZE</span><span class=p>,</span> <span class=n>regression</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>DetectorScaleInvarianceTest</span> <span class=nf>test</span><span class=p>(</span><span class=n>Algorithm</span><span class=o>::</span><span class=n>create</span><span class=o>&lt;</span><span class=n>FeatureDetector</span><span class=o>&gt;</span><span class=p>(</span><span class=s>&#34;Feature2D.KAZE&#34;</span><span class=p>),</span>
</span></span><span class=line><span class=cl>        <span class=mf>0.08f</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=mf>0.49f</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>test</span><span class=p>.</span><span class=n>safe_run</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>TEST</span><span class=p>(</span><span class=n>Features2d_ScaleInvariance_Detector_AKAZE</span><span class=p>,</span> <span class=n>regression</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>DetectorScaleInvarianceTest</span> <span class=nf>test</span><span class=p>(</span><span class=n>Algorithm</span><span class=o>::</span><span class=n>create</span><span class=o>&lt;</span><span class=n>FeatureDetector</span><span class=o>&gt;</span><span class=p>(</span><span class=s>&#34;Feature2D.AKAZE&#34;</span><span class=p>),</span>
</span></span><span class=line><span class=cl>        <span class=mf>0.08f</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=mf>0.49f</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>test</span><span class=p>.</span><span class=n>safe_run</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=step-11---enabling-multithreading>Step 11 - Enabling multithreading</h3><p>Both, feature detection and extraction stage can be made faster by using multi-threading.
Fortunately, AKAZE designed very clear and one may are find OpenMP instructions in critical sections:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#pragma omp parallel for
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=p>(</span><span class=kt>int</span><span class=p>)(</span><span class=n>kpts</span><span class=p>.</span><span class=n>size</span><span class=p>());</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Compute_Main_Orientation</span><span class=p>(</span><span class=n>kpts</span><span class=p>[</span><span class=n>i</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=n>Get_SURF_Descriptor_64</span><span class=p>(</span><span class=n>kpts</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=n>desc</span><span class=p>.</span><span class=n>ptr</span><span class=o>&lt;</span><span class=kt>float</span><span class=o>&gt;</span><span class=p>(</span><span class=n>i</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>But OpenCV uses abstraction layer for multithreading called <code>cv::parallel_for_</code>. Personally I think it&rsquo;s very wise architectural desing decision since it allows to get rid of specific cavetas for particular threading backends (OpenCV, TBB, Concurrency, GCD, etc). You can read more about using cv::parallel_for_ in one of my <a href=/articles/2012-11-06-maximizing-performance-grayscale-color-conversion-using-neon-and-cvparallel_for/>previous posts</a> or visit <a href=http://answers.opencv.org/question/3730/how-to-use-parallel_for/>OpenCV documentation</a>.</p><p>For instance, here is how to parallelize building of the nonlinear scale space for AKAZE. The old version of OpenMP version of <code>Compute_Multiscale_Derivatives</code> function looked like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * @brief This method computes the multiscale derivatives for the nonlinear scale space
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>AKAZEFeatures</span><span class=o>::</span><span class=n>Compute_Multiscale_Derivatives</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cp>#pragma omp parallel for
</span></span></span><span class=line><span class=cl><span class=cp></span>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=p>(</span><span class=kt>int</span><span class=p>)(</span><span class=n>evolution_</span><span class=p>.</span><span class=n>size</span><span class=p>());</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=kt>float</span> <span class=n>ratio</span> <span class=o>=</span> <span class=n>pow</span><span class=p>(</span><span class=mf>2.f</span><span class=p>,</span> <span class=p>(</span><span class=kt>float</span><span class=p>)</span><span class=n>evolution_</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>octave</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>sigma_size_</span> <span class=o>=</span> <span class=n>fRound</span><span class=p>(</span><span class=n>evolution_</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>esigma</span><span class=o>*</span><span class=n>options_</span><span class=p>.</span><span class=n>derivative_factor</span> <span class=o>/</span> <span class=n>ratio</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>compute_scharr_derivatives</span><span class=p>(</span><span class=n>evolution_</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>Lsmooth</span><span class=p>,</span> <span class=n>evolution_</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>Lx</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=n>sigma_size_</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>compute_scharr_derivatives</span><span class=p>(</span><span class=n>evolution_</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>Lsmooth</span><span class=p>,</span> <span class=n>evolution_</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>Ly</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=n>sigma_size_</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>compute_scharr_derivatives</span><span class=p>(</span><span class=n>evolution_</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>Lx</span><span class=p>,</span> <span class=n>evolution_</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>Lxx</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=n>sigma_size_</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>compute_scharr_derivatives</span><span class=p>(</span><span class=n>evolution_</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>Ly</span><span class=p>,</span> <span class=n>evolution_</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>Lyy</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=n>sigma_size_</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>compute_scharr_derivatives</span><span class=p>(</span><span class=n>evolution_</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>Lx</span><span class=p>,</span> <span class=n>evolution_</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>Lxy</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=n>sigma_size_</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>evolution_</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>Lx</span> <span class=o>=</span> <span class=n>evolution_</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>Lx</span><span class=o>*</span><span class=p>((</span><span class=n>sigma_size_</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=n>evolution_</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>Ly</span> <span class=o>=</span> <span class=n>evolution_</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>Ly</span><span class=o>*</span><span class=p>((</span><span class=n>sigma_size_</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=n>evolution_</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>Lxx</span> <span class=o>=</span> <span class=n>evolution_</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>Lxx</span><span class=o>*</span><span class=p>((</span><span class=n>sigma_size_</span><span class=p>)</span><span class=o>*</span><span class=p>(</span><span class=n>sigma_size_</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=n>evolution_</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>Lxy</span> <span class=o>=</span> <span class=n>evolution_</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>Lxy</span><span class=o>*</span><span class=p>((</span><span class=n>sigma_size_</span><span class=p>)</span><span class=o>*</span><span class=p>(</span><span class=n>sigma_size_</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=n>evolution_</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>Lyy</span> <span class=o>=</span> <span class=n>evolution_</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>Lyy</span><span class=o>*</span><span class=p>((</span><span class=n>sigma_size_</span><span class=p>)</span><span class=o>*</span><span class=p>(</span><span class=n>sigma_size_</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Using <code>cv::parallel_for_</code> we introduce an &lsquo;invoker&rsquo; function object that perform a discrete piece of job on small subset of whole data. Threading API does all job on scheduling multithreaded execution among worker threads:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>MultiscaleDerivativesInvoker</span> <span class=o>:</span> <span class=k>public</span> <span class=n>cv</span><span class=o>::</span><span class=n>ParallelLoopBody</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>explicit</span> <span class=n>MultiscaleDerivativesInvoker</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>TEvolution</span><span class=o>&gt;&amp;</span> <span class=n>ev</span><span class=p>,</span> <span class=k>const</span> <span class=n>AKAZEOptions</span><span class=o>&amp;</span> <span class=n>opt</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>    <span class=o>:</span> <span class=n>evolution_</span><span class=p>(</span><span class=n>ev</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>,</span> <span class=n>options_</span><span class=p>(</span><span class=n>opt</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>operator</span><span class=p>()(</span><span class=k>const</span> <span class=n>cv</span><span class=o>::</span><span class=n>Range</span><span class=o>&amp;</span> <span class=n>range</span><span class=p>)</span> <span class=k>const</span> 
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>range</span><span class=p>.</span><span class=n>start</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>range</span><span class=p>.</span><span class=n>end</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=kt>float</span> <span class=n>ratio</span> <span class=o>=</span> <span class=n>pow</span><span class=p>(</span><span class=mf>2.f</span><span class=p>,</span> <span class=p>(</span><span class=kt>float</span><span class=p>)</span><span class=n>evolution_</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>octave</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=kt>int</span> <span class=n>sigma_size_</span> <span class=o>=</span> <span class=n>fRound</span><span class=p>(</span><span class=n>evolution_</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>esigma</span> <span class=o>*</span> <span class=n>options_</span><span class=p>.</span><span class=n>derivative_factor</span> <span class=o>/</span> <span class=n>ratio</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=n>compute_scharr_derivatives</span><span class=p>(</span><span class=n>evolution_</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>Lsmooth</span><span class=p>,</span> <span class=n>evolution_</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>Lx</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=n>sigma_size_</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>compute_scharr_derivatives</span><span class=p>(</span><span class=n>evolution_</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>Lsmooth</span><span class=p>,</span> <span class=n>evolution_</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>Ly</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=n>sigma_size_</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>compute_scharr_derivatives</span><span class=p>(</span><span class=n>evolution_</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>Lx</span><span class=p>,</span> <span class=n>evolution_</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>Lxx</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=n>sigma_size_</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>compute_scharr_derivatives</span><span class=p>(</span><span class=n>evolution_</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>Ly</span><span class=p>,</span> <span class=n>evolution_</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>Lyy</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=n>sigma_size_</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>compute_scharr_derivatives</span><span class=p>(</span><span class=n>evolution_</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>Lx</span><span class=p>,</span> <span class=n>evolution_</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>Lxy</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=n>sigma_size_</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=n>evolution_</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>Lx</span> <span class=o>=</span> <span class=n>evolution_</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>Lx</span><span class=o>*</span><span class=p>((</span><span class=n>sigma_size_</span><span class=p>));</span>
</span></span><span class=line><span class=cl>            <span class=n>evolution_</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>Ly</span> <span class=o>=</span> <span class=n>evolution_</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>Ly</span><span class=o>*</span><span class=p>((</span><span class=n>sigma_size_</span><span class=p>));</span>
</span></span><span class=line><span class=cl>            <span class=n>evolution_</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>Lxx</span> <span class=o>=</span> <span class=n>evolution_</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>Lxx</span><span class=o>*</span><span class=p>((</span><span class=n>sigma_size_</span><span class=p>)</span><span class=o>*</span><span class=p>(</span><span class=n>sigma_size_</span><span class=p>));</span>
</span></span><span class=line><span class=cl>            <span class=n>evolution_</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>Lxy</span> <span class=o>=</span> <span class=n>evolution_</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>Lxy</span><span class=o>*</span><span class=p>((</span><span class=n>sigma_size_</span><span class=p>)</span><span class=o>*</span><span class=p>(</span><span class=n>sigma_size_</span><span class=p>));</span>
</span></span><span class=line><span class=cl>            <span class=n>evolution_</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>Lyy</span> <span class=o>=</span> <span class=n>evolution_</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>Lyy</span><span class=o>*</span><span class=p>((</span><span class=n>sigma_size_</span><span class=p>)</span><span class=o>*</span><span class=p>(</span><span class=n>sigma_size_</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>mutable</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>TEvolution</span><span class=o>&gt;</span> <span class=o>&amp;</span> <span class=n>evolution_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>AKAZEOptions</span>                      <span class=n>options_</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * @brief This method computes the multiscale derivatives for the nonlinear scale space
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>AKAZEFeatures</span><span class=o>::</span><span class=n>Compute_Multiscale_Derivatives</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>cv</span><span class=o>::</span><span class=n>parallel_for_</span><span class=p>(</span><span class=n>cv</span><span class=o>::</span><span class=n>Range</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>evolution_</span><span class=p>.</span><span class=n>size</span><span class=p>()),</span> 
</span></span><span class=line><span class=cl>                      <span class=n>MultiscaleDerivativesInvoker</span><span class=p>(</span><span class=n>evolution_</span><span class=p>,</span> <span class=n>options_</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p></p><h1 id=kaze-performance>KAZE performance</h1><p>After integration I ran KAZE and AKAZE using <a href=https://github.com/BloodAxe/OpenCV-Features-Comparison>feature descriptor estimation framework</a> to see how they perform. I was really impressed about matching precision on rotation and scaling tests. Look at these self-explaining charts where <strong>AKAZE beats all other features</strong>!</p><h1 id=references>References</h1><ul><li><a href=https://github.com/BloodAxe/opencv/tree/kaze>KAZE Integration branch on GitHub</a></li><li><a href=http://www.robesafe.com/personal/pablo.alcantarilla/code/kaze_features_1.6.0.tar.gz>KAZE 1.6 implementation</a></li><li><a href=http://www.robesafe.com/personal/pablo.alcantarilla/code/akaze_features_1.1.0.tar.gz>AKAZE 1.2 implementation</a></li></ul></div><div class=post__footer><span><a class=tag href=/tags/opencv/>opencv</a><a class=tag href=/tags/algorithms/>algorithms</a></span></div><div id=comment><h2>comments</h2><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//cvtalks.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></div></main></div><footer class="footer footer__base"><ul class=footer__list><li class=footer__item>&copy;
Eugene Khvedchenya
2022</li></ul></footer><script type=text/javascript src=/js/medium-zoom.min.9c062c557275acbaba71f0c7cd4024da3e3cc825d248bc4b2130811b0965330b.js integrity="sha256-nAYsVXJ1rLq6cfDHzUAk2j48yCXSSLxLITCBGwllMws=" crossorigin=anonymous></script>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-10687369-5","auto"),ga("send","pageview"))</script><script async src=https://www.google-analytics.com/analytics.js></script></body></html>